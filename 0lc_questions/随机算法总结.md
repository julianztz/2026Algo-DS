# 随机算法总结

## 一、三大随机算法概览

| 算法 | 问题 | 时间复杂度 | 空间复杂度 | 核心思想 |
|------|------|-----------|-----------|---------|
| **Fisher-Yates** | 打乱数组 | O(n) | O(1) | 每个位置与后续随机位置交换 |
| **Reservoir Sampling** | 从流中随机选择 | O(n) | O(1) | 动态概率：第i个元素以1/i概率选择 |
| **Weighted Random** | 带权重随机选择 | O(log n) | O(n) | 前缀和 + 二分查找 |

---

## 二、Fisher-Yates 洗牌算法

### 问题
打乱数组，使得每个排列等概率出现（概率 = 1/n!）

### 核心思想
对于位置 i，从 [i, n-1] 中随机选择一个位置交换（**包括 i 本身**）

### 关键代码
```python
for i in range(len(nums) - 1):
    r = random.randint(i, len(nums) - 1)  # ⚠️ 必须包括 i
    nums[i], nums[r] = nums[r], nums[i]
```

### 关键点
1. **随机范围必须是 [i, n-1]**，不是 [i+1, n-1]
   - 如果只从 [i+1, n-1] 选择，位置 i 的元素永远不会留在原位置
   - 这会导致某些排列永远不会出现

2. **每个排列的概率 = 1/n!**
   - 第1个位置：n 种选择，每个元素概率 = 1/n
   - 第2个位置：n-1 种选择，每个元素概率 = 1/(n-1)
   - ...
   - 总概率 = (1/n) × (1/(n-1)) × ... × (1/1) = 1/n!

### 应用场景
- 洗牌（扑克牌）
- 随机排列数组
- 需要知道数组长度

---

## 三、Reservoir Sampling（蓄水池抽样）

### 问题
从未知长度的流/链表中随机选择一个元素，每个元素被选中的概率相等（1/n）

### 核心思想
对于第 i 个元素，以 1/i 的概率选择它，以 (i-1)/i 的概率保持原有选择

### 关键代码
```python
res = 0
i = 0
p = head

while p != None:
    i += 1
    rand_num = random.randint(0, i-1)  # [0, i-1] 包括两端
    if rand_num == 0:  # 概率 = 1/i
        res = p.val
    p = p.next

return res
```

### 数学证明
**第 i 个元素被选中的概率：**
```
P(第i个) = P(在第i步选中) × P(第i+1步不替换) × ... × P(第n步不替换)
        = (1/i) × (1-1/(i+1)) × (1-1/(i+2)) × ... × (1-1/n)
        = (1/i) × (i/(i+1)) × ((i+1)/(i+2)) × ... × ((n-1)/n)
        = 1/n
```

### 关键点
1. **随机范围是 [0, i-1]**（包括两端）
2. **只需要检查 rand_num == 0**，概率就是 1/i
3. **不需要知道总长度**，适合流式数据

### 应用场景
- 从大数据流中随机采样
- 链表长度未知
- 只能顺序访问，不能随机访问

---

## 四、带权重随机选择（Weighted Random Pick）

### 问题
根据权重随机选择索引，权重越大，被选中的概率越大

### 核心思想
1. **前缀和**：将权重映射到区间
2. **随机数**：生成 [1, total] 之间的随机数
3. **二分查找**：找第一个 >= target 的位置

### 关键代码
```python
# 1. 计算前缀和
self.preSum = [w[0]]
for i in range(1, len(w)):
    self.preSum.append(self.preSum[i-1] + w[i])  # ⚠️ 必须是累积的

# 2. 生成随机数并查找
target = random.randint(1, self.preSum[-1])

# 3. 二分查找：找第一个 >= target 的位置
left, right = 0, len(self.preSum) - 1
while left < right:
    mid = (left + right) // 2
    if self.preSum[mid] < target:
        left = mid + 1
    else:  # preSum[mid] >= target
        right = mid

return left  # ⚠️ 直接返回 left，不需要 -1
```

### 区间映射示例
**w = [1, 3, 2]，preSum = [1, 4, 6]**

| 索引 | 权重 | 区间 | 概率 |
|------|------|------|------|
| 0 | 1 | [1, 1] | 1/6 |
| 1 | 3 | [2, 4] | 3/6 |
| 2 | 2 | [5, 6] | 2/6 |

**随机选择：**
- target = 1 → 索引 0
- target = 2, 3, 4 → 索引 1
- target = 5, 6 → 索引 2

### 关键点
1. **前缀和计算**：必须是累积的 `preSum[i] = preSum[i-1] + w[i]`
2. **二分查找**：找第一个 `>= target` 的位置（左边界）
3. **返回值**：直接返回 `left`，不需要减 1

### 常见错误
- ❌ `w[i] + w[i-1]` → ✅ `preSum[i-1] + w[i]`
- ❌ `return left - 1` → ✅ `return left`
- ❌ `left = mid`（可能死循环）→ ✅ `right = mid` 或 `left = mid + 1`

### 应用场景
- 根据权重随机选择
- 概率分布不均匀的随机选择
- 需要快速查询（O(log n)）

---

## 五、三种算法对比

| 维度 | Fisher-Yates | Reservoir Sampling | Weighted Random |
|------|-------------|-------------------|----------------|
| **输入** | 已知长度的数组 | 未知长度的流 | 权重数组 |
| **输出** | 打乱后的数组 | 一个随机元素 | 一个随机索引 |
| **需要长度** | ✅ 是 | ❌ 否 | ✅ 是 |
| **需要随机访问** | ✅ 是（交换） | ❌ 否（顺序遍历） | ✅ 是（二分查找） |
| **修改原数据** | ✅ 是 | ❌ 否 | ❌ 否 |
| **概率分布** | 每个排列 1/n! | 每个元素 1/n | 按权重比例 |
| **时间复杂度** | O(n) | O(n) | O(log n) |
| **空间复杂度** | O(1) | O(1) | O(n) |

---

## 六、关键注意事项

### Fisher-Yates
1. ⚠️ 随机范围必须是 `[i, n-1]`，包括 i 本身
2. ⚠️ 如果只从 `[i+1, n-1]` 选择，某些排列永远不会出现

### Reservoir Sampling
1. ⚠️ 随机范围是 `[0, i-1]`（包括两端）
2. ⚠️ 只需要检查 `rand_num == 0`，概率就是 1/i
3. ⚠️ 第一个元素一定会被选择（i=1 时，rand_num 只能是 0）

### Weighted Random
1. ⚠️ 前缀和必须是累积的：`preSum[i] = preSum[i-1] + w[i]`
2. ⚠️ 二分查找找第一个 `>= target` 的位置
3. ⚠️ 直接返回 `left`，不需要减 1
4. ⚠️ 避免死循环：`left = mid + 1` 或 `right = mid`

---

## 七、验证方法

### Fisher-Yates
- 运行多次，统计每个排列出现的频率
- 验证是否所有排列都可能出现
- 验证每个排列的频率是否接近 1/n!

### Reservoir Sampling
- 运行多次（如 10000 次），统计每个元素被选中的频率
- 验证每个元素的频率是否接近 1/n
- 验证所有元素都出现过

### Weighted Random
- 运行多次，统计每个索引被选中的频率
- 验证频率是否与权重成正比
- 验证 `频率[i] / 频率[j] ≈ w[i] / w[j]`

---

## 八、200字核心总结

随机算法三大类：Fisher-Yates洗牌用于打乱数组，关键是从[i,n-1]随机选择（包括i），确保每个排列等概率1/n!；Reservoir Sampling用于从未知长度流中随机选择，第i个元素以1/i概率选择，每个元素最终概率1/n，适合大数据流；Weighted Random用前缀和+二分查找实现带权重选择，前缀和必须累积计算，二分找第一个>=target位置，直接返回left。关键陷阱：Fisher-Yates必须包括i本身，Reservoir只需检查rand_num==0，Weighted Random前缀和用preSum[i-1]+w[i]不是w[i]+w[i-1]，返回值直接left不減1。验证方法：运行大量试验统计频率，Fisher-Yates验证排列均匀，Reservoir验证元素均匀，Weighted验证权重比例。


