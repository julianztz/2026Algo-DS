# 链表反转问题总结

## 一、反转过程问题分析

### 你的问题：反转前 3(pre) -> 2(cur) -> 1(nxt)，第一次循环后是否变成双向？

**答案：❌ 不会变成双向**

让我详细分析反转过程：

**初始状态（反转后半部分 [1,2,3] 时）：**
```
3 -> 2 -> 1 -> None
^    ^    ^
pre  cur  nxt
```

**第一次循环：**
```python
cur.next = pre  # 2.next = 3，所以 2 -> 3
pre = cur       # pre = 节点 2
cur = nxt       # cur = 节点 1
nxt = nxt.next  # nxt = None
```

**第一次循环后：**
```
3 <- 2 -> 1 -> None
^    ^    ^
     pre  cur  nxt(None)
```

**关键点：**
- 节点 2 的 `next` 指向节点 3（`2 -> 3`）
- 节点 3 的 `next` 仍然指向节点 2（`3 -> 2`）❌ **这是错误的！**

**实际上，节点 3 的 `next` 在之前的循环中已经被改变了：**
- 在反转 `[1,2,3]` 时，节点 3 是第一个被处理的节点
- 当 `cur = 节点 3` 时，`cur.next = pre = None`
- 所以节点 3 的 `next` 已经指向 `None`，不是节点 2

**正确的反转过程：**

**初始状态（反转 [1,2,3]）：**
```
None <- 3 -> 2 -> 1 -> None
^      ^    ^    ^
pre    cur  nxt
```

**第1次循环（处理节点 3）：**
```
3.next = None
pre = 节点 3
cur = 节点 2
nxt = 节点 1
```

**第1次循环后：**
```
None <- 3 -> None    2 -> 1 -> None
^      ^            ^    ^
       pre          cur  nxt
```

**第2次循环（处理节点 2）：**
```
2.next = 节点 3
pre = 节点 2
cur = 节点 1
nxt = None
```

**第2次循环后：**
```
None <- 3 <- 2 -> None    1 -> None
^      ^    ^            ^
              pre        cur
```

**第3次循环（处理节点 1）：**
```
1.next = 节点 2
pre = 节点 1
cur = None
```

**最终结果：**
```
None <- 3 <- 2 <- 1 -> None
^      ^    ^    ^
              pre cur(None)
```

**返回 `pre`（节点 1）作为新的头节点**

---

## 二、链表反转问题总结（200字）

### 核心思路

**迭代方法（三指针）：** `pre, cur, nxt` 三个指针，每次循环 `cur.next = pre` 反转链接，然后三个指针依次后移。适用于完全反转、部分反转、k组反转。

**递归方法：** 递归到链表末尾，从后往前反转，`head.next.next = head` 建立反向链接。逻辑清晰但空间复杂度O(n)。

**头插法：** `prev` 和 `cur` 位置不变作为锚点，每次将 `cur.next` 插入到 `prev` 后面。适用于部分反转（reverseBetween）、k组反转。

**快慢指针 + 反转：** 快慢指针找中点，反转后半部分，然后比较。适用于回文判断。

### 关键技巧

**Dummy节点**处理头节点可能改变的情况；**三指针**保证反转过程中不丢失节点；**头插法**中 `prev` 和 `cur` 作为锚点；**快慢指针**一次遍历找中点。

