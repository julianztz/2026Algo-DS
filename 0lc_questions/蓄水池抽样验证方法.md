# 蓄水池抽样（Reservoir Sampling）算法验证方法

## 一、数学证明验证

### 1. 基本思路

对于第 i 个元素，它被最终选中的概率 = 它在第 i 步被选中 × 后续所有步骤都没有替换它

### 2. 数学推导

**第 i 个元素被选中的概率：**

```
P(第i个元素被选中) = P(在第i步选中) × P(第i+1步不替换) × P(第i+2步不替换) × ... × P(第n步不替换)
                  = (1/i) × (1 - 1/(i+1)) × (1 - 1/(i+2)) × ... × (1 - 1/n)
                  = (1/i) × (i/(i+1)) × ((i+1)/(i+2)) × ... × ((n-1)/n)
                  = 1/n
```

**详细步骤：**
- 第 i 步：选中第 i 个元素的概率 = 1/i
- 第 i+1 步：不替换的概率 = 1 - 1/(i+1) = i/(i+1)
- 第 i+2 步：不替换的概率 = 1 - 1/(i+2) = (i+1)/(i+2)
- ...
- 第 n 步：不替换的概率 = 1 - 1/n = (n-1)/n

**结果：**
所有项相乘后，分子分母相消，最终得到 1/n

### 3. 具体例子（n=4）

**第1个元素（i=1）：**
```
P = (1/1) × (1-1/2) × (1-1/3) × (1-1/4)
  = 1 × (1/2) × (2/3) × (3/4)
  = 1/4
```

**第2个元素（i=2）：**
```
P = (1/2) × (1-1/3) × (1-1/4)
  = (1/2) × (2/3) × (3/4)
  = 1/4
```

**第3个元素（i=3）：**
```
P = (1/3) × (1-1/4)
  = (1/3) × (3/4)
  = 1/4
```

**第4个元素（i=4）：**
```
P = 1/4
```

所有元素被选中的概率都是 1/4 ✓

---

## 二、实验验证方法

### 方法1：统计频率验证

**步骤：**
1. 运行算法 N 次（N 足够大，如 10000 次）
2. 统计每个元素被选中的次数
3. 计算每个元素的频率
4. 验证频率是否接近 1/n

**Python 验证代码示例：**
```python
def verify_reservoir_sampling(linked_list, n_trials=10000):
    """
    验证蓄水池抽样的正确性
    
    参数：
    - linked_list: 链表头节点
    - n_trials: 试验次数（越大越准确）
    """
    from collections import Counter
    
    linkedls = Linkedlist_shuffle(linked_list)
    results = []
    
    # 运行多次
    for _ in range(n_trials):
        result = linkedls.getRandom()
        results.append(result)
    
    # 统计频率
    counter = Counter(results)
    total = len(results)
    n = len(counter)  # 链表长度
    
    print(f"总试验次数: {total}")
    print(f"链表长度: {n}")
    print(f"期望概率: {1/n:.2%}")
    print(f"\n每个元素被选中的频率:")
    
    all_correct = True
    for val, count in sorted(counter.items()):
        freq = count / total
        expected = 1 / n
        diff = abs(freq - expected)
        status = '✓' if diff < 0.02 else '✗'  # 允许 2% 的误差
        print(f"  元素 {val}: {count} 次 ({freq:.2%}), 期望: {expected:.2%}, 误差: {diff:.2%} {status}")
        if diff >= 0.02:
            all_correct = False
    
    return all_correct
```

**判断标准：**
- 如果每个元素的频率都在 1/n ± 2% 范围内，认为算法正确
- 试验次数越多，结果越准确（大数定律）

### 方法2：卡方检验（Chi-square Test）

**步骤：**
1. 运行算法 N 次
2. 统计每个元素被选中的次数（观察值 O_i）
3. 计算期望值 E = N/n
4. 计算卡方统计量：χ² = Σ((O_i - E)² / E)
5. 与卡方分布比较，判断是否显著

**Python 验证代码示例：**
```python
from scipy.stats import chi2

def chi_square_test(linked_list, n_trials=10000):
    """
    使用卡方检验验证算法正确性
    """
    from collections import Counter
    
    linkedls = Linkedlist_shuffle(linked_list)
    results = []
    
    for _ in range(n_trials):
        result = linkedls.getRandom()
        results.append(result)
    
    counter = Counter(results)
    n = len(counter)  # 链表长度
    expected = n_trials / n
    
    # 计算卡方统计量
    chi_square = sum((count - expected) ** 2 / expected for count in counter.values())
    
    # 自由度 = n - 1
    df = n - 1
    
    # 显著性水平 0.05
    critical_value = chi2.ppf(0.95, df)
    
    print(f"卡方统计量: {chi_square:.2f}")
    print(f"临界值 (α=0.05): {critical_value:.2f}")
    print(f"自由度: {df}")
    
    if chi_square < critical_value:
        print("✓ 通过卡方检验：算法正确（p > 0.05）")
        return True
    else:
        print("✗ 未通过卡方检验：算法可能有问题（p < 0.05）")
        return False
```

---

## 三、边界情况验证

### 1. 单元素链表
```python
node = ListNode(42)
linkedls = Linkedlist_shuffle(node)
result = linkedls.getRandom()
assert result == 42  # 应该总是返回 42
```

### 2. 两个元素的链表
```python
node = ListNode(1)
node.next = ListNode(2)
linkedls = Linkedlist_shuffle(node)

# 运行多次，验证每个元素概率都是 1/2
results = [linkedls.getRandom() for _ in range(10000)]
counter = Counter(results)
# 应该接近 5000:5000
```

### 3. 空链表（如果支持）
```python
# 检查是否会正确处理空链表
```

---

## 四、逐步跟踪验证

### 手动跟踪示例（n=3）

**链表：[1, 2, 3]**

**第1步（i=1，处理节点1）：**
- `rand_num = random.randint(0, 0) = 0`
- `rand_num == 0` → True
- `res = 1`
- 当前 res = 1，概率 = 1/1 = 100%

**第2步（i=2，处理节点2）：**
- `rand_num = random.randint(0, 1)` → 可能是 0 或 1
- 如果 `rand_num == 0`（概率 1/2）→ `res = 2`
- 如果 `rand_num == 1`（概率 1/2）→ `res` 保持为 1
- 节点2被选中的概率 = 1/2

**第3步（i=3，处理节点3）：**
- `rand_num = random.randint(0, 2)` → 可能是 0, 1, 或 2
- 如果 `rand_num == 0`（概率 1/3）→ `res = 3`
- 如果 `rand_num != 0`（概率 2/3）→ `res` 保持不变
- 节点3被选中的概率 = 1/3

**最终概率：**
- 节点1：P = (1/1) × (1-1/2) × (1-1/3) = 1 × (1/2) × (2/3) = 1/3
- 节点2：P = (1/2) × (1-1/3) = (1/2) × (2/3) = 1/3
- 节点3：P = 1/3

所有节点概率都是 1/3 ✓

---

## 五、代码验证示例（不修改原代码）

```python
# 验证代码（独立文件，不修改原代码）
from collections import Counter
import random

# 假设 Linkedlist_shuffle 类已经定义
# 这里只是验证代码

def verify_algorithm():
    """验证蓄水池抽样算法"""
    
    # 创建测试链表 [1, 2, 3, 4]
    node = ListNode(1)
    node.next = ListNode(2)
    node.next.next = ListNode(3)
    node.next.next.next = ListNode(4)
    
    linkedls = Linkedlist_shuffle(node)
    
    # 方法1：统计频率
    print("=== 方法1：统计频率验证 ===")
    n_trials = 10000
    results = [linkedls.getRandom() for _ in range(n_trials)]
    counter = Counter(results)
    
    n = len(counter)  # 链表长度
    expected_prob = 1 / n
    
    print(f"试验次数: {n_trials}")
    print(f"链表长度: {n}")
    print(f"期望概率: {expected_prob:.2%}\n")
    
    all_correct = True
    for val in sorted(counter.keys()):
        count = counter[val]
        freq = count / n_trials
        diff = abs(freq - expected_prob)
        status = '✓' if diff < 0.02 else '✗'
        print(f"元素 {val}: {count} 次 ({freq:.2%}), 期望: {expected_prob:.2%}, 误差: {diff:.2%} {status}")
        if diff >= 0.02:
            all_correct = False
    
    return all_correct

# 运行验证
if __name__ == '__main__':
    verify_algorithm()
```

---

## 六、验证标准总结

### ✅ 算法正确的标志：

1. **数学证明**：每个元素被选中的概率都是 1/n
2. **实验验证**：运行大量试验后，每个元素的频率接近 1/n（误差 < 2%）
3. **卡方检验**：通过卡方检验（p > 0.05）
4. **边界情况**：单元素、两元素等边界情况都正确
5. **逐步跟踪**：手动跟踪几个例子，验证逻辑正确

### ⚠️ 可能的问题：

1. **频率偏差过大**：如果某个元素的频率明显偏离 1/n，可能有问题
2. **某些元素从未出现**：如果某个元素在大量试验中从未出现，肯定有问题
3. **边界情况失败**：单元素链表等边界情况处理错误

---

## 七、快速验证清单

- [ ] 数学证明：每个元素概率 = 1/n
- [ ] 运行 10000 次，统计频率
- [ ] 验证每个元素频率接近 1/n（误差 < 2%）
- [ ] 测试单元素链表
- [ ] 测试两元素链表
- [ ] 手动跟踪一个小例子（如 n=3）

如果以上都通过，算法就是正确的！


