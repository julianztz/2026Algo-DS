# 双指针解决数组问题总结

## 一、快慢指针（同向移动）

**核心思想**：两个指针从同一侧开始，一个快一个慢，快指针遍历，慢指针维护结果区。

### 1. 删除/移除类问题

#### 26. Remove Duplicates from Sorted Array
- **问题**：删除排序数组中的重复项，每个元素只出现一次
- **思路**：
  - `slow` 指向下一个唯一元素应该放置的位置
  - `fast` 遍历数组找到唯一的元素
  - 当 `nums[fast] != nums[slow]` 时，说明找到新的唯一元素
- **关键代码**：
```python
slow = 0
for fast in range(1, len(nums)):
    if nums[fast] != nums[slow]:
        slow += 1
        nums[slow] = nums[fast]
return slow + 1
```

#### 27. Remove Element
- **问题**：移除数组中所有等于 val 的元素
- **思路**：
  - `slow` 指向下一个非 val 元素应该放置的位置
  - `fast` 遍历数组，跳过 val
- **关键代码**：
```python
slow = 0
for fast in range(len(nums)):
    if nums[fast] != val:
        nums[slow] = nums[fast]
        slow += 1
return slow
```

#### 283. Move Zeroes
- **问题**：将所有 0 移动到数组末尾，保持非零元素的相对顺序
- **思路1**（推荐）：
  - `slow` 指向下一个非零元素应该放置的位置
  - `fast` 遍历数组，遇到非零就交换并前进
- **思路2**：
  - `slow` 记录第一个 0 的位置
  - `fast` 遍历，遇到非零且 slow 是 0 时交换
- **关键代码**：
```python
slow = 0
for fast in range(len(nums)):
    if nums[fast] != 0:
        nums[slow], nums[fast] = nums[fast], nums[slow]
        slow += 1
```

### 2. 合并类问题

#### 88. Merge Sorted Array
- **问题**：合并两个有序数组到 nums1
- **思路**：从后往前合并，利用尾部空间避免覆盖
- **关键代码**：
```python
i, j, p = m-1, n-1, len(nums1)-1
while i >= 0 and j >= 0:
    if nums1[i] >= nums2[j]:
        nums1[p] = nums1[i]
        i -= 1
    else:
        nums1[p] = nums2[j]
        j -= 1
    p -= 1
```

---

## 二、左右指针（相向移动）

**核心思想**：两个指针从两端开始，根据条件相向移动。

### 1. 反转类问题

#### 344. Reverse String
- **问题**：反转字符数组
- **思路**：左右指针交换，向中间靠拢
- **关键代码**：
```python
left, right = 0, len(s) - 1
while left < right:
    s[left], s[right] = s[right], s[left]
    left += 1
    right -= 1
```

#### 151. Reverse Words in String
- **问题**：反转字符串中的单词顺序
- **思路**：先 split 成数组，再用左右指针反转
- **关键代码**：
```python
arr = s.split()
l, r = 0, len(arr) - 1
while l < r:
    arr[l], arr[r] = arr[r], arr[l]
    l += 1
    r -= 1
```

### 2. 搜索/查找类问题

#### 167. Two Sum II - Input Array Is Sorted
- **问题**：在有序数组中找到两个数，使它们的和等于目标值
- **思路**：利用有序性，根据和的大小移动指针
- **关键代码**：
```python
left, right = 0, len(numbers) - 1
while left < right:
    s = numbers[left] + numbers[right]
    if s > target:
        right -= 1
    elif s < target:
        left += 1
    else:
        return [left+1, right+1]
```

#### 15. 3Sum
- **问题**：找到所有和为 0 的三元组
- **思路**：固定第一个数，在剩余部分用双指针找 twoSum
- **关键代码**：
```python
for i in range(len(nums) - 2):
    left, right = i + 1, len(nums) - 1
    while left < right:
        s = nums[i] + nums[left] + nums[right]
        if s == 0:
            res.append([nums[i], nums[left], nums[right]])
            # 跳过重复
            while left < right and nums[left] == nums[left+1]:
                left += 1
            left += 1
            right -= 1
        elif s < 0:
            left += 1
        else:
            right -= 1
```

### 3. 回文类问题

#### 5. Longest Palindromic Substring
- **问题**：找到最长回文子串
- **思路**：以每个字符为中心，用左右指针扩展
- **关键代码**：
```python
def findPalindrome(s, l, r):
    while l >= 0 and r < len(s) and s[l] == s[r]:
        l -= 1
        r += 1
    return s[l+1:r]

for i in range(len(s)):
    s1 = findPalindrome(s, i, i)      # 奇数长度
    s2 = findPalindrome(s, i, i+1)    # 偶数长度
```

---

## 三、滑动窗口（快慢指针的变种）

**核心思想**：维护一个窗口，根据条件扩展或收缩。

### 1. 子串/子数组问题

#### 76. Minimum Window Substring
- **问题**：找到包含 t 中所有字符的最短子串
- **思路**：滑动窗口 + 哈希表记录字符频率
- **关键代码**：
```python
left = right = 0
while right < len(s):
    # 扩大窗口
    window[s[right]] += 1
    right += 1
    
    # 收缩窗口
    while valid(window, need):
        # 更新结果
        if right - left < min_len:
            min_len = right - left
            res = s[left:right]
        
        window[s[left]] -= 1
        left += 1
```

#### 3. Longest Substring Without Repeating Characters
- **问题**：找到最长无重复字符的子串
- **思路**：滑动窗口 + 哈希表记录字符出现次数
- **关键代码**：
```python
left = right = 0
while right < len(s):
    window[s[right]] += 1
    right += 1
    
    # 有重复，收缩窗口
    while window[s[right-1]] > 1:
        window[s[left]] -= 1
        left += 1
    
    res = max(res, right - left)
```

#### 567. Permutation in String
- **问题**：判断 s2 是否包含 s1 的排列
- **思路**：固定大小的滑动窗口
- **关键代码**：
```python
targetLen = len(s1)
window = Counter(s2[:targetLen])
if window == Counter(s1):
    return True

for i in range(targetLen, len(s2)):
    window[s2[i-targetLen]] -= 1
    window[s2[i]] += 1
    if window == Counter(s1):
        return True
```

#### 438. Find All Anagrams in String
- **问题**：找到所有 s 中 p 的变位词的起始索引
- **思路**：类似 567，记录所有匹配位置
- **关键代码**：
```python
left = right = 0
while right < len(s):
    window[s[right]] += 1
    right += 1
    
    if right - left >= len(p):
        if valid(window, need):
            res.append(left)
        window[s[left]] -= 1
        left += 1
```

---

## 四、双指针模式总结

### 模式1：快慢指针（同向）
- **适用场景**：删除、移除、合并、原地修改
- **模板**：
```python
slow = 0
for fast in range(len(nums)):
    if condition:
        nums[slow] = nums[fast]
        slow += 1
```

### 模式2：左右指针（相向）
- **适用场景**：反转、搜索、回文、有序数组
- **模板**：
```python
left, right = 0, len(nums) - 1
while left < right:
    if condition:
        left += 1
    else:
        right -= 1
```

### 模式3：滑动窗口
- **适用场景**：子串、子数组、连续区间
- **模板**：
```python
left = right = 0
while right < len(s):
    # 扩大窗口
    window[s[right]] += 1
    right += 1
    
    # 收缩窗口
    while need_shrink:
        window[s[left]] -= 1
        left += 1
```

---

## 五、问题分类速查表

| 问题类型 | LeetCode 题号 | 双指针类型 | 关键点 |
|---------|--------------|-----------|--------|
| 删除重复 | 26 | 快慢指针 | slow 维护结果区 |
| 移除元素 | 27 | 快慢指针 | slow 跳过目标值 |
| 移动零 | 283 | 快慢指针 | slow 维护非零区 |
| 合并数组 | 88 | 快慢指针（反向） | 从后往前避免覆盖 |
| 反转字符串 | 344 | 左右指针 | 两端交换 |
| 反转单词 | 151 | 左右指针 | 先 split 再反转 |
| 两数之和 | 167 | 左右指针 | 利用有序性 |
| 三数之和 | 15 | 左右指针 | 固定一个，双指针找两个 |
| 最长回文 | 5 | 左右指针 | 中心扩展 |
| 最小窗口 | 76 | 滑动窗口 | 哈希表 + 窗口收缩 |
| 无重复子串 | 3 | 滑动窗口 | 哈希表记录频率 |
| 字符串排列 | 567 | 滑动窗口 | 固定窗口大小 |
| 找变位词 | 438 | 滑动窗口 | 记录所有匹配位置 |

---

## 六、选择双指针的时机

### ✅ 适合用双指针的情况：
1. **数组已排序** → 左右指针（如 Two Sum II）
2. **需要原地修改** → 快慢指针（如 Remove Duplicates）
3. **子串/子数组问题** → 滑动窗口（如 Longest Substring）
4. **回文问题** → 中心扩展（如 Longest Palindrome）
5. **需要减少空间复杂度** → 双指针通常 O(1) 空间

### ❌ 不适合用双指针的情况：
1. **需要随机访问** → 用哈希表
2. **需要回溯** → 用回溯算法
3. **需要动态规划** → 用 DP
4. **无序数组查找** → 用哈希表或排序

---

## 七、常见陷阱和注意事项

1. **边界条件**：空数组、单元素数组
2. **指针移动顺序**：先判断再移动，避免越界
3. **重复元素处理**：需要去重时注意跳过重复
4. **窗口收缩条件**：确保窗口收缩后仍满足条件
5. **索引 vs 值**：注意返回索引还是值

---

## 八、练习建议

1. **基础**：26, 27, 283, 344
2. **进阶**：167, 15, 88
3. **高级**：76, 3, 567, 438
4. **综合**：5, 151

按顺序练习，逐步掌握双指针的各种模式！






