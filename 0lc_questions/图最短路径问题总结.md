# å›¾æœ€çŸ­è·¯å¾„é—®é¢˜æ€»ç»“

## ğŸ“‹ ç›®å½•
1. [ç®—æ³•é€‰æ‹©ï¼šBFS vs Dijkstra](#ç®—æ³•é€‰æ‹©)
2. [BFS æ¨¡æ¿](#bfs-æ¨¡æ¿)
3. [Dijkstra æ¨¡æ¿](#dijkstra-æ¨¡æ¿)
4. [å¸¸è§å˜ç§é—®é¢˜](#å¸¸è§å˜ç§é—®é¢˜)
5. [å…³é”®æ³¨æ„äº‹é¡¹](#å…³é”®æ³¨æ„äº‹é¡¹)
6. [å®æˆ˜æŠ€å·§](#å®æˆ˜æŠ€å·§)

---

## ğŸ¯ ç®—æ³•é€‰æ‹©

### ä»€ä¹ˆæ—¶å€™ç”¨ BFSï¼Ÿ

**é€‚ç”¨åœºæ™¯ï¼š**
- âœ… **æ— æƒå›¾**ï¼ˆæ‰€æœ‰è¾¹æƒé‡ç›¸ç­‰ï¼Œæˆ–è§†ä¸º 1ï¼‰
- âœ… æ±‚**æœ€çŸ­æ­¥æ•°/å±‚æ•°**ï¼ˆä¸æ˜¯è·¯å¾„æƒé‡å’Œï¼‰
- âœ… æ±‚**æœ€å°‘è½¬æ¢æ¬¡æ•°**
- âœ… å›¾æ˜¯**æ— å‘å›¾**æˆ–**æœ‰å‘å›¾**éƒ½å¯ä»¥

**æ—¶é—´å¤æ‚åº¦ï¼š** O(V + E)  
**ç©ºé—´å¤æ‚åº¦ï¼š** O(V)

**å…¸å‹é—®é¢˜ï¼š**
- è¿·å®«æœ€çŸ­è·¯å¾„ï¼ˆæ­¥æ•°ï¼‰
- å•è¯æ¥é¾™ï¼ˆè½¬æ¢æ¬¡æ•°ï¼‰
- ç¤¾äº¤ç½‘ç»œä¸­çš„æœ€çŸ­è·¯å¾„ï¼ˆæœ‹å‹å…³ç³»æ•°ï¼‰

### ä»€ä¹ˆæ—¶å€™ç”¨ Dijkstraï¼Ÿ

**é€‚ç”¨åœºæ™¯ï¼š**
- âœ… **æœ‰æƒå›¾**ï¼ˆè¾¹æœ‰ä¸åŒçš„æƒé‡ï¼‰
- âœ… æ±‚**æœ€çŸ­è·¯å¾„æƒé‡å’Œ**
- âœ… **æ— è´Ÿæƒé‡è¾¹**ï¼ˆé‡è¦ï¼ï¼‰
- âœ… å•æºæœ€çŸ­è·¯å¾„é—®é¢˜

**æ—¶é—´å¤æ‚åº¦ï¼š** O(E log V)ï¼ˆä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼‰  
**ç©ºé—´å¤æ‚åº¦ï¼š** O(V + E)

**å…¸å‹é—®é¢˜ï¼š**
- ç½‘ç»œå»¶è¿Ÿæ—¶é—´ï¼ˆNetwork Delay Timeï¼‰
- æœ€ä¾¿å®œçš„èˆªç­ï¼ˆCheapest Flightsï¼‰
- åœ°å›¾å¯¼èˆªï¼ˆæœ€çŸ­è·ç¦»/æ—¶é—´ï¼‰

### å†³ç­–æµç¨‹å›¾

```
å›¾çš„æœ€çŸ­è·¯å¾„é—®é¢˜
    â”‚
    â”œâ”€ æ˜¯å¦æœ‰è¾¹æƒé‡ï¼Ÿ
    â”‚   â”‚
    â”‚   â”œâ”€ å¦ â†’ ç”¨ BFS âœ…
    â”‚   â”‚
    â”‚   â””â”€ æ˜¯ â†’ æ˜¯å¦æœ‰è´Ÿæƒé‡è¾¹ï¼Ÿ
    â”‚       â”‚
    â”‚       â”œâ”€ æ˜¯ â†’ ç”¨ Bellman-Ford æˆ– SPFA
    â”‚       â”‚
    â”‚       â””â”€ å¦ â†’ ç”¨ Dijkstra âœ…
    â”‚
    â””â”€ æ˜¯å¦æœ‰é¢å¤–é™åˆ¶ï¼ˆå¦‚ stops æ•°ï¼‰ï¼Ÿ
        â”‚
        â””â”€ æ˜¯ â†’ æ”¹è¿›çš„ Dijkstra æˆ– Bellman-Ford
```

---

## ğŸ”µ BFS æ¨¡æ¿

### æ ‡å‡† BFS æ¨¡æ¿ï¼ˆæ— æƒå›¾æœ€çŸ­è·¯å¾„ï¼‰

```python
from collections import deque

def bfs_shortest_path(graph, start, target):
    """
    ä½¿ç”¨ BFS æ‰¾æ— æƒå›¾ä¸­çš„æœ€çŸ­è·¯å¾„
    """
    # 1. åˆå§‹åŒ–
    queue = deque([start])
    visited = set([start])
    distance = {start: 0}  # è®°å½•åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„è·ç¦»
    
    # 2. BFS éå†
    while queue:
        node = queue.popleft()
        
        # å¦‚æœæ‰¾åˆ°ç›®æ ‡ï¼Œè¿”å›è·ç¦»
        if node == target:
            return distance[node]
        
        # éå†é‚»å±…
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                distance[neighbor] = distance[node] + 1
                queue.append(neighbor)
    
    # å¦‚æœæ— æ³•åˆ°è¾¾ç›®æ ‡
    return -1
```

### å¸¦å±‚æ•°è®°å½•çš„ BFSï¼ˆæ›´å¸¸ç”¨ï¼‰

```python
def bfs_with_levels(graph, start, target):
    """
    ä½¿ç”¨ BFS æ‰¾æœ€çŸ­è·¯å¾„ï¼ŒæŒ‰å±‚éå†
    """
    queue = deque([start])
    visited = set([start])
    level = 0  # å½“å‰å±‚æ•°
    
    while queue:
        size = len(queue)
        
        # éå†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
        for _ in range(size):
            node = queue.popleft()
            
            if node == target:
                return level
            
            # å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        level += 1  # è¿›å…¥ä¸‹ä¸€å±‚
    
    return -1
```

---

## ğŸŸ¢ Dijkstra æ¨¡æ¿

### æ ‡å‡† Dijkstra æ¨¡æ¿ï¼ˆå•æºæœ€çŸ­è·¯å¾„ï¼‰

```python
import heapq
from typing import List, Dict, Tuple

def dijkstra(graph: Dict[int, List[Tuple[int, int]]], src: int) -> Dict[int, int]:
    """
    Dijkstra ç®—æ³•ï¼šè®¡ç®—ä»æºèŠ‚ç‚¹ src åˆ°æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    
    å‚æ•°:
        graph: é‚»æ¥è¡¨ {node: [(neighbor, weight), ...]}
        src: æºèŠ‚ç‚¹
    
    è¿”å›:
        distTo: {node: min_distance}
    """
    # 1. åˆå§‹åŒ–è·ç¦»æ•°ç»„
    distTo = {node: float('inf') for node in graph}
    distTo[src] = 0
    
    # 2. ä¼˜å…ˆé˜Ÿåˆ—ï¼š(è·ç¦», èŠ‚ç‚¹)
    pq = [(0, src)]
    visited = set()
    
    # 3. ä¸»å¾ªç¯
    while pq:
        dist, node = heapq.heappop(pq)
        
        # è·³è¿‡å·²è®¿é—®çš„èŠ‚ç‚¹ï¼ˆå¯èƒ½æœ‰é‡å¤èŠ‚ç‚¹åœ¨é˜Ÿåˆ—ä¸­ï¼‰
        if node in visited:
            continue
        
        visited.add(node)
        
        # 4. æ¾å¼›æ“ä½œï¼šæ›´æ–°é‚»å±…èŠ‚ç‚¹çš„è·ç¦»
        for neighbor, weight in graph.get(node, []):
            if dist + weight < distTo[neighbor]:
                distTo[neighbor] = dist + weight
                heapq.heappush(pq, (distTo[neighbor], neighbor))
    
    return distTo
```

### ä»è¾¹åˆ—è¡¨æ„å»ºå›¾çš„è¾…åŠ©å‡½æ•°

```python
def build_graph(edges: List[List[int]]) -> Dict[int, List[Tuple[int, int]]]:
    """
    å°†è¾¹åˆ—è¡¨è½¬æ¢ä¸ºé‚»æ¥è¡¨
    
    è¾“å…¥: [[u, v, w], ...] æˆ– [[u, v], ...]ï¼ˆæ— æƒå›¾ï¼‰
    è¾“å‡º: {u: [(v, w), ...]}
    """
    graph = {}
    for edge in edges:
        u, v = edge[0], edge[1]
        w = edge[2] if len(edge) > 2 else 1  # é»˜è®¤æƒé‡ä¸º 1
        
        if u not in graph:
            graph[u] = []
        graph[u].append((v, w))
    
    return graph
```

---

## ğŸ”´ å¸¸è§å˜ç§é—®é¢˜

### 1. å¸¦ Stops é™åˆ¶çš„æœ€çŸ­è·¯å¾„

**é—®é¢˜ï¼š** åœ¨æœ€å¤š k ä¸ªä¸­é—´èŠ‚ç‚¹çš„æƒ…å†µä¸‹ï¼Œæ‰¾æœ€çŸ­è·¯å¾„

**å…³é”®ç‚¹ï¼š**
- çŠ¶æ€æ˜¯**äºŒç»´çš„**ï¼š`(node, stops)` è€Œä¸æ˜¯ `node`
- åŒä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½éœ€è¦åœ¨**ä¸åŒçš„ stops æ•°ä¸‹è¢«è®¿é—®å¤šæ¬¡**
- **ä¸èƒ½ç”¨ç®€å•çš„ visited é›†åˆ**

**æ¨¡æ¿ï¼š**

```python
def dijkstra_with_stops(n, edges, src, dst, k):
    """
    å¸¦ stops é™åˆ¶çš„ Dijkstra
    """
    # æ„å»ºå›¾
    graph = build_graph(edges)
    
    # ä¼˜å…ˆé˜Ÿåˆ—ï¼š(cost, node, stops)
    pq = [(0, src, 0)]
    
    # è®°å½•æ¯ä¸ª (node, stops) çŠ¶æ€çš„æœ€å° cost
    min_cost = {}  # {(node, stops): min_cost}
    
    while pq:
        cost, node, stops = heapq.heappop(pq)
        
        # åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        if node == dst:
            return cost
        
        # è¶…è¿‡ stops é™åˆ¶ï¼Œè·³è¿‡
        if stops > k:
            continue
        
        # æ£€æŸ¥æ˜¯å¦å·²è®¿é—®è¿‡è¿™ä¸ªçŠ¶æ€
        if (node, stops) in min_cost and cost >= min_cost[(node, stops)]:
            continue
        
        min_cost[(node, stops)] = cost
        
        # éå†é‚»å±…
        for neighbor, weight in graph.get(node, []):
            new_cost = cost + weight
            new_stops = stops + 1
            
            if new_stops <= k + 1:
                if (neighbor, new_stops) not in min_cost or new_cost < min_cost[(neighbor, new_stops)]:
                    heapq.heappush(pq, (new_cost, neighbor, new_stops))
    
    return -1
```

### 2. å¤šæºæœ€çŸ­è·¯å¾„

**æ–¹æ³•1ï¼š** å¯¹æ¯ä¸ªæºèŠ‚ç‚¹è¿è¡Œ Dijkstraï¼ˆO(V * E log V)ï¼‰  
**æ–¹æ³•2ï¼š** Floyd-Warshall ç®—æ³•ï¼ˆO(VÂ³)ï¼‰

### 3. è´Ÿæƒé‡è¾¹

**ä¸èƒ½ç”¨ Dijkstraï¼** ä½¿ç”¨ï¼š
- **Bellman-Ford**ï¼šO(V * E)
- **SPFA**ï¼ˆæ”¹è¿›çš„ Bellman-Fordï¼‰ï¼šå¹³å‡ O(E)ï¼Œæœ€å O(V * E)

---

## âš ï¸ å…³é”®æ³¨æ„äº‹é¡¹

### 1. å›¾çš„è¡¨ç¤ºæ–¹å¼

**é‚»æ¥è¡¨ï¼ˆæ¨èï¼‰ï¼š**
```python
graph = {
    0: [(1, 4), (3, 2)],  # èŠ‚ç‚¹0åˆ°èŠ‚ç‚¹1æƒé‡4ï¼Œåˆ°èŠ‚ç‚¹3æƒé‡2
    1: [(2, 1)],
    2: []
}
```

**è¾¹åˆ—è¡¨è½¬é‚»æ¥è¡¨ï¼š**
```python
# è¾“å…¥ï¼š[[u, v, w], ...]
graph = {}
for u, v, w in edges:
    if u not in graph:
        graph[u] = []
    graph[u].append((v, w))
```

### 2. èŠ‚ç‚¹ç¼–å·é—®é¢˜

**å¸¸è§é”™è¯¯ï¼š**
- èŠ‚ç‚¹ç¼–å·ä» 0 å¼€å§‹ vs ä» 1 å¼€å§‹
- åˆå§‹åŒ– `distTo` æ—¶ç´¢å¼•é”™è¯¯

**æ­£ç¡®åšæ³•ï¼š**
```python
# å¦‚æœèŠ‚ç‚¹ç¼–å·æ˜¯ 0 åˆ° n-1
distTo = {i: float('inf') for i in range(n)}

# å¦‚æœèŠ‚ç‚¹ç¼–å·æ˜¯ 1 åˆ° n
distTo = {i: float('inf') for i in range(1, n + 1)}
```

### 3. visited é›†åˆçš„ä½¿ç”¨

**æ ‡å‡† Dijkstraï¼š**
```python
if node in visited:
    continue
visited.add(node)
```
âœ… æ­£ç¡®ï¼šä¸€æ—¦æ‰¾åˆ°æœ€çŸ­è·¯å¾„ï¼Œå°±ä¸éœ€è¦å†è®¿é—®

**å¸¦é™åˆ¶çš„ Dijkstraï¼š**
```python
# âŒ é”™è¯¯ï¼šä¸èƒ½ç”¨ç®€å•çš„ visited
visited.add(node)  # è¿™ä¼šé˜»æ­¢åŒä¸€èŠ‚ç‚¹åœ¨ä¸åŒ stops ä¸‹çš„è®¿é—®

# âœ… æ­£ç¡®ï¼šç”¨ (node, stops) ä½œä¸ºçŠ¶æ€
if (node, stops) in min_cost and cost >= min_cost[(node, stops)]:
    continue
```

### 4. ä¼˜å…ˆé˜Ÿåˆ—çš„ä½¿ç”¨

**æ­£ç¡®ç”¨æ³•ï¼š**
```python
# âœ… æ­£ç¡®ï¼šå…ƒç»„ (è·ç¦», èŠ‚ç‚¹)
heapq.heappush(pq, (dist, node))

# âŒ é”™è¯¯ï¼šä¸èƒ½ä¼ å¤šä¸ªå‚æ•°
heapq.heappush(pq, dist, node)  # TypeError!
```

**å¤šç»´åº¦çŠ¶æ€ï¼š**
```python
# âœ… æ­£ç¡®ï¼šå…ƒç»„ (cost, node, stops)
heapq.heappush(pq, (cost, node, stops))
```

### 5. è·ç¦»æ›´æ–°æ¡ä»¶

**æ ‡å‡† Dijkstraï¼š**
```python
if dist + weight < distTo[neighbor]:
    distTo[neighbor] = dist + weight
    heapq.heappush(pq, (distTo[neighbor], neighbor))
```

**å¸¦é™åˆ¶çš„ Dijkstraï¼š**
```python
# éœ€è¦åŒæ—¶æ£€æŸ¥ stops é™åˆ¶å’Œ cost æ˜¯å¦æ›´ä¼˜
if new_stops <= k + 1:
    if (neighbor, new_stops) not in min_cost or new_cost < min_cost[(neighbor, new_stops)]:
        heapq.heappush(pq, (new_cost, neighbor, new_stops))
```

### 6. æå‰è¿”å›ä¼˜åŒ–

**åˆ°è¾¾ç›®æ ‡èŠ‚ç‚¹æ—¶ï¼š**
```python
# âœ… å¯ä»¥æå‰è¿”å›ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ä¿è¯è¿™æ˜¯æœ€çŸ­è·¯å¾„ï¼‰
if node == dst:
    return cost
```

**ä½†è¦æ³¨æ„ï¼š** å¦‚æœè¦æ±‚æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œä¸èƒ½æå‰è¿”å›ã€‚

### 7. ä¸å¯è¾¾èŠ‚ç‚¹æ£€æŸ¥

**æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹æ˜¯å¦å¯è¾¾ï¼š**
```python
# æ–¹æ³•1ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ inf å€¼
if any(dist == float('inf') for dist in distTo.values()):
    return -1

# æ–¹æ³•2ï¼šæ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹
for node in range(1, n + 1):
    if distTo.get(node, float('inf')) == float('inf'):
        return -1
```

---

## ğŸ’¡ å®æˆ˜æŠ€å·§

### 1. å¿«é€Ÿåˆ¤æ–­ç®—æ³•é€‰æ‹©

| ç‰¹å¾ | ç®—æ³• |
|------|------|
| æ— æƒå›¾ | BFS |
| æœ‰æƒå›¾ï¼Œæ— è´Ÿæƒé‡ | Dijkstra |
| æœ‰æƒå›¾ï¼Œæœ‰è´Ÿæƒé‡ | Bellman-Ford |
| å¸¦ stops é™åˆ¶ | æ”¹è¿›çš„ Dijkstra |
| å¤šæºæœ€çŸ­è·¯å¾„ | Floyd-Warshall |

### 2. å¸¸è§é”™è¯¯æ£€æŸ¥æ¸…å•

- [ ] å›¾çš„æ„å»ºæ˜¯å¦æ­£ç¡®ï¼Ÿï¼ˆé‚»æ¥è¡¨æ ¼å¼ï¼‰
- [ ] èŠ‚ç‚¹ç¼–å·æ˜¯å¦ä¸€è‡´ï¼Ÿï¼ˆ0-indexed vs 1-indexedï¼‰
- [ ] visited é›†åˆä½¿ç”¨æ˜¯å¦æ­£ç¡®ï¼Ÿï¼ˆå¸¦é™åˆ¶æ—¶ä¸èƒ½ç”¨ç®€å• visitedï¼‰
- [ ] ä¼˜å…ˆé˜Ÿåˆ—å‚æ•°æ˜¯å¦æ­£ç¡®ï¼Ÿï¼ˆå…ƒç»„æ ¼å¼ï¼‰
- [ ] è·ç¦»æ›´æ–°æ¡ä»¶æ˜¯å¦æ­£ç¡®ï¼Ÿ
- [ ] æ˜¯å¦æ£€æŸ¥äº†ä¸å¯è¾¾èŠ‚ç‚¹ï¼Ÿ
- [ ] æ˜¯å¦æœ‰æå‰è¿”å›çš„é€»è¾‘ï¼Ÿ

### 3. è°ƒè¯•æŠ€å·§

**æ‰“å°ä¸­é—´çŠ¶æ€ï¼š**
```python
print(f"Processing node {node}, dist={dist}, stops={stops}")
print(f"distTo: {distTo}")
print(f"Queue size: {len(pq)}")
```

**å¯è§†åŒ–å›¾ç»“æ„ï¼š**
```python
for node, neighbors in graph.items():
    print(f"{node} -> {neighbors}")
```

### 4. æ€§èƒ½ä¼˜åŒ–

**ä½¿ç”¨ defaultdictï¼š**
```python
from collections import defaultdict

graph = defaultdict(list)
for u, v, w in edges:
    graph[u].append((v, w))
```

**æå‰ç»ˆæ­¢ï¼š**
```python
# å¦‚æœåªè¦æ±‚åˆ°ç›®æ ‡èŠ‚ç‚¹çš„è·ç¦»
if node == dst:
    return cost
```

---

## ğŸ“š ç»å…¸é¢˜ç›®åˆ†ç±»

### BFS ç±»
- 127. Word Ladderï¼ˆå•è¯æ¥é¾™ï¼‰
- 1091. Shortest Path in Binary Matrixï¼ˆäºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„ï¼‰
- 934. Shortest Bridgeï¼ˆæœ€çŸ­æ¡¥ï¼‰

### Dijkstra ç±»
- 743. Network Delay Timeï¼ˆç½‘ç»œå»¶è¿Ÿæ—¶é—´ï¼‰
- 787. Cheapest Flights Within K Stopsï¼ˆæœ€ä¾¿å®œçš„èˆªç­ï¼‰
- 1514. Path with Maximum Probabilityï¼ˆæœ€å¤§æ¦‚ç‡è·¯å¾„ï¼‰

### å¸¦é™åˆ¶çš„ Dijkstra
- 787. Cheapest Flights Within K Stopsï¼ˆk ä¸ª stopsï¼‰
- 1928. Minimum Cost to Reach Destination in Timeï¼ˆæ—¶é—´é™åˆ¶ï¼‰

---

## ğŸ¯ æ€»ç»“

### æ ¸å¿ƒåŸåˆ™

1. **æ— æƒå›¾ â†’ BFS**ï¼šç®€å•é«˜æ•ˆï¼ŒO(V + E)
2. **æœ‰æƒå›¾ â†’ Dijkstra**ï¼šè´ªå¿ƒ + ä¼˜å…ˆé˜Ÿåˆ—ï¼ŒO(E log V)
3. **æœ‰è´Ÿæƒé‡ â†’ Bellman-Ford**ï¼šä¸èƒ½ç”¨ Dijkstra
4. **å¸¦é™åˆ¶ â†’ æ”¹è¿›ç®—æ³•**ï¼šçŠ¶æ€æ˜¯äºŒç»´çš„ `(node, constraint)`

### å…³é”®æ¨¡æ¿

**BFSï¼š**
```python
queue + visited + distance
```

**Dijkstraï¼š**
```python
priority_queue + visited + distTo
```

**å¸¦é™åˆ¶çš„ Dijkstraï¼š**
```python
priority_queue + min_cost[(node, constraint)]
```

### è®°å¿†è¦ç‚¹

- âœ… å…ˆåˆ¤æ–­å›¾çš„ç±»å‹ï¼ˆæœ‰æƒ/æ— æƒï¼‰
- âœ… å†åˆ¤æ–­æ˜¯å¦æœ‰é¢å¤–é™åˆ¶
- âœ… æ³¨æ„èŠ‚ç‚¹ç¼–å·ï¼ˆ0-indexed vs 1-indexedï¼‰
- âœ… å¸¦é™åˆ¶æ—¶ä¸èƒ½ç”¨ç®€å• visited
- âœ… ä¼˜å…ˆé˜Ÿåˆ—ç”¨å…ƒç»„æ ¼å¼








