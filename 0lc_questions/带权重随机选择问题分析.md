# 带权重随机选择（Random Pick with Weight）问题分析

## 一、你的实现分析

### 问题1：前缀和计算错误 ❌

**你的代码：**
```python
self.preSum = [w[0]]
for i in range(1, len(w)):
    self.preSum.append(w[i] + w[i-1])  # ❌ 错误
```

**问题：**
- 前缀和应该是累积的，但这里用的是 `w[i] + w[i-1]`，而不是 `w[i] + self.preSum[i-1]`

**示例：w = [1, 2, 3]**
- 你的计算：preSum = [1, 3, 5]
  - preSum[0] = 1 ✓
  - preSum[1] = w[1] + w[0] = 2 + 1 = 3 ✓（碰巧对了）
  - preSum[2] = w[2] + w[1] = 3 + 2 = 5 ✗（应该是 6）

- 正确计算：preSum = [1, 3, 6]
  - preSum[0] = 1
  - preSum[1] = w[1] + preSum[0] = 2 + 1 = 3
  - preSum[2] = w[2] + preSum[1] = 3 + 3 = 6

**修正：**
```python
self.preSum = [w[0]]
for i in range(1, len(w)):
    self.preSum.append(w[i] + self.preSum[i-1])  # ✅ 正确
```

### 问题2：二分搜索逻辑错误 ❌

**你的代码：**
```python
res = -1
left = 0
right = len(self.preSum) - 1
while left < right:
    mid = (left + right) // 2
    if target == self.preSum[mid]:
        res = mid
    elif target < self.preSum[mid]:
        right = mid - 1
    elif target > self.preSum[mid]:
        left = mid  # ❌ 可能导致死循环

return res - 1  # ❌ 返回值错误
```

**问题：**

1. **`res = -1` 初始化问题**：
   - 如果 `target` 不等于任何 `preSum[mid]`，`res` 仍然是 -1
   - 最终返回 `-1 - 1 = -2`，这是错误的

2. **`left = mid` 可能导致死循环**：
   - 当 `left == mid` 且 `target > preSum[mid]` 时，`left` 不变，死循环
   - 例如：`left=1, right=2, mid=1`，如果 `target > preSum[1]`，`left = mid = 1`，循环不终止

3. **`return res - 1` 错误**：
   - 如果找到 `target == preSum[mid]`，`res = mid`，返回 `mid - 1`
   - 但 `target == preSum[mid]` 时，应该返回 `mid`（因为 target 在区间 [preSum[mid-1]+1, preSum[mid]]）

4. **循环条件 `left < right` 问题**：
   - 应该用 `left <= right` 或者正确处理边界

### 问题3：二分搜索目标理解错误

**正确的理解：**
- 前缀和 preSum[i] 表示索引 0 到 i 的权重总和
- 对于 target，我们要找第一个 `preSum[i] >= target` 的索引 i
- 这样 target 就落在区间 `(preSum[i-1], preSum[i]]` 中，对应索引 i

**示例：w = [1, 3]，preSum = [1, 4]**
- target = 1：应该在区间 [1, 1]，返回索引 0
- target = 2, 3, 4：应该在区间 [2, 4]，返回索引 1

---

## 二、正确的实现

### 方法1：前缀和 + 二分查找（查找左边界）

```python
class RandomPickWithWeight:
    def __init__(self, w: List[int]):
        # ✅ 正确的前缀和计算
        self.preSum = [w[0]]
        for i in range(1, len(w)):
            self.preSum.append(w[i] + self.preSum[i-1])

    def pickIndex(self) -> int:
        # 生成 [1, total] 之间的随机数
        target = random.randint(1, self.preSum[-1])
        
        # ✅ 二分查找：找第一个 >= target 的位置
        left, right = 0, len(self.preSum) - 1
        
        while left < right:
            mid = (left + right) // 2
            if self.preSum[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left
```

**关键点：**
- 找第一个 `preSum[i] >= target` 的位置
- 使用标准的二分查找左边界模板

### 方法2：使用 bisect 模块（更简洁）

```python
import bisect

class RandomPickWithWeight:
    def __init__(self, w: List[int]):
        self.preSum = [w[0]]
        for i in range(1, len(w)):
            self.preSum.append(w[i] + self.preSum[i-1])

    def pickIndex(self) -> int:
        target = random.randint(1, self.preSum[-1])
        # bisect_left 找第一个 >= target 的位置
        return bisect.bisect_left(self.preSum, target)
```

---

## 三、算法原理

### 前缀和的作用

**示例：w = [1, 3, 2]**
- preSum = [1, 4, 6]
- 总权重 = 6

**区间映射：**
- 索引 0：区间 [1, 1]，长度 = 1，概率 = 1/6
- 索引 1：区间 [2, 4]，长度 = 3，概率 = 3/6
- 索引 2：区间 [5, 6]，长度 = 2，概率 = 2/6

**随机选择：**
- 生成 target ∈ [1, 6]
- 如果 target = 1 → 索引 0
- 如果 target ∈ [2, 4] → 索引 1
- 如果 target ∈ [5, 6] → 索引 2

### 二分查找的目标

找第一个 `preSum[i] >= target` 的索引 i，这样：
- `target <= preSum[i]`
- `target > preSum[i-1]`（如果 i > 0）
- 所以 target 落在区间 `(preSum[i-1], preSum[i]]`，对应索引 i

---

## 四、你的代码问题总结

| 问题 | 位置 | 错误 | 修正 |
|------|------|------|------|
| 前缀和计算 | `__init__` | `w[i] + w[i-1]` | `w[i] + self.preSum[i-1]` |
| 二分搜索初始化 | `pickIndex` | `res = -1` | 不需要 res，直接用 left |
| 二分搜索循环 | `pickIndex` | `left = mid` 可能死循环 | `left = mid + 1` 或 `right = mid` |
| 返回值 | `pickIndex` | `return res - 1` | `return left` |

---

## 五、测试验证

**测试用例：w = [1, 3]**
- 正确的前缀和：[1, 4]
- target = 1 → 应该返回 0
- target = 2, 3, 4 → 应该返回 1

**测试用例：w = [1, 2, 3]**
- 正确的前缀和：[1, 3, 6]
- target = 1 → 返回 0
- target = 2, 3 → 返回 1
- target = 4, 5, 6 → 返回 2

---

## 六、修正后的完整代码

```python
class RandomPickWithWeight:
    def __init__(self, w: List[int]):
        # ✅ 正确的前缀和计算
        self.preSum = [w[0]]
        for i in range(1, len(w)):
            self.preSum.append(w[i] + self.preSum[i-1])

    def pickIndex(self) -> int:
        # 生成 [1, total] 之间的随机数
        target = random.randint(1, self.preSum[-1])
        
        # ✅ 二分查找：找第一个 >= target 的位置
        left, right = 0, len(self.preSum) - 1
        
        while left < right:
            mid = (left + right) // 2
            if self.preSum[mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left
```


