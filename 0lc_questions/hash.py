from typing import Any, Optional, List


# 1. two sum     [2 7 11 15]
'''
O(n) extra space for dictionary

O(1) 排序 + 左右指针
'''
def twoSum(nums, target) -> List[int]:
    d = {}
    for i in range(len(nums)):
        complement = target - nums[i]
        if complement in d:
            return [d[complement], i]
        d[nums[i]] = i
    
    return []




# 290 word pattern
# Given a pattern and a string s, find if s follows the same pattern. 
# Here follow means a full match, 
# such that there is a bijection between a letter in pattern and a non-empty word in s
def wordPattern(pattern: str, s: str) -> bool:
    map = {}
    s_list = s.split(" ")
    used_s = set()

    if len(pattern) != len(s_list):
        return False

    for i, l in enumerate(pattern):
        if l in map:
            if map[l] != s_list[i]:
                return False
        else:                          # new pattern
            if s_list[i] in used_s:    # 检查双向映射
                return False
            map[l] = s_list[i]
            used_s.add(s_list[i])

    return True


# 242 valid anagram
#   ！！ 一个 dictionary 减法！！
def isAnagram(s: str, t: str) -> bool:
    map = dict()
    if len(s) != len(t):
        return False

    for l in s:
        map[l] = map.get(l, 0) + 1      # single line of 首次0，第二次+1

    for l in t:
        map[l] = map.get(l, 0) - 1  # 如果不存在，默认为0再减1
        if map[l] < 0:  # 如果小于0，说明t中的字符多了
            return False
        # if l not in map:      # 等价 但是更加复杂
        #     return False
        # else:
        #     map[l] -= 1
        #     if map[l] < 0:
        #         return False
    return True

def isAnagram2(s:str, t:str):
    return sorted(s) == sorted(t)



# 387 first unique char in a string
def firstUniqChar(s: str) -> int:
    map = {}
    for l in s:
        map[l] = map.get(l, 0) + 1

    for i, char in enumerate(s):  # 直接遍历字符串，保证顺序
        if map[char] == 1:
            return i
    return -1


# 169 majority element
# The majority element is the element that appears more than [n/2] times.
# You may assume that the majority element always exists in the array

# Follow-up: Could you solve the problem in linear time and in O(1) space?
def majorityElement(nums: List[int]) -> int:
    map = {}
    for n in nums:
        map[n] = map.get(n, 0) + 1
        if map[n] > len(nums) / 2:
            return n

def majorityElement_O1_space(nums: List[int]) -> int:
    candidate = None
    count = 0
    
    for n in nums:
        if count == 0:
            candidate = n
        # count += 1 if n == candidate else -1 的等价形式：
        if n == candidate:
            count += 1
        else:
            count -= 1
    
    return candidate


# ========================================
# Boyer-Moore 算法总结
# ========================================
'''
注意：有两种不同的"Boyer-Moore"算法！

1. Boyer-Moore Majority Vote Algorithm（本文件使用的）
   - 发明：1991年，J Strother Moore
   - 用途：找多数元素（出现次数 > n/2）
   - 核心：候选+计数器，抵消机制
   - 复杂度：O(n) time, O(1) space

2. Boyer-Moore String Matching Algorithm（字符串匹配）
   - 发明：1977年，Boyer & Moore
   - 用途：在文本中搜索模式串
   - 核心：从右向左比较，坏字符规则，好后缀规则
   - 复杂度：O(n+m) 平均，O(n*m) 最坏

本文件使用的是第一种（Majority Vote）！

算法思想（Majority Vote）：
1. 核心假设：存在一个元素出现次数 > n/2
2. 关键洞察：多数元素的出现次数 > 其他所有元素的总和
3. 执行策略：
   - 维护一个候选者 (candidate) 和一个计数器 (count)
   - 遍历数组：相同元素 count+1，不同元素 count-1
   - 当 count=0 时，更换候选者
   - 由于多数元素 > n/2，它能够"存活"到最后

时间复杂度：O(n) - 单次遍历
空间复杂度：O(1) - 只用两个变量

应用场景：
1. 多数元素问题（出现次数 > n/2）
2. 信号处理中的占优频率检测
3. 投票系统中的多数派确定
4. 领导选举算法

局限性：
- 只适用于"严格多数"（> n/2）的情况
- 对于其他频率检测问题不适用

优点：
+ 在线性时间和常数空间内解决问题
+ 实现简单
+ 不需要额外数据结构

缺点：
- 只适用于特定的多数元素问题
- 需要保证多数元素一定存在
- 不适于"相对多数"（可能是 ≤ n/2）的场景
'''


# 389 find difference
# You are given two strings s and t.
# String t is generated by random shuffling string s and then add one more letter at a random position.
# Return the letter that was added to t.
def findTheDifference(s: str, t: str) -> str:
    map = {}
    for ele in s:
        map[ele] = map.get(ele, 0) + 1

    for ele in t:
        map[ele] = map.get(ele, 0) - 1
        if map[ele] < 0:
            return ele

# 389 方法2：字符代码相加
# t 比 s 多一个字符，所有字符的ASCII值之和的差就是新字符
# O(n) time, O(1) space
def findTheDifference_ascii(s: str, t: str) -> str:
    sum_s = sum(ord(c) for c in s)
    sum_t = sum(ord(c) for c in t)
    return chr(sum_t - sum_s)

# 389 方法3：异或运算（优雅但难理解）
# 两个相同字符异或结果为0，最终剩下的是新字符
# O(n) time, O(1) space
def findTheDifference_xor(s: str, t: str) -> str:
    result = 0
    for c in s:
        result ^= ord(c)
    for c in t:
        result ^= ord(c)
    return chr(result)



# 448. Find All Numbers Disappeared in an Array
# followup:  time: O(n)   space: no extra
def findDisappearedNumbers(nums: List[int]) -> List[int]:
    res = []
    map = dict()
    for i in range(len(nums)):
        map[i+1] = 0

    for n in nums:
        map[n] += 1

    for k, v in map.items():
        if v == 0:
            res.append(k)
    return res


# ！！不推荐！！ O(1)空间解法（followup）：利用数组索引  
# 用负号标记出现的数字
def findDisappearedNumbers_O1_space(nums: List[int]) -> List[int]:
    # 标记出现过的数字为负数
    for i in range(len(nums)):
        index = abs(nums[i]) - 1
        if nums[index] > 0:
            nums[index] = -nums[index]
    
    # 找出仍然为正数的索引
    result = []
    for i in range(len(nums)):
        if nums[i] > 0:
            result.append(i + 1)
    
    return result


# 128 longest consecutive sequence
# Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
# You must write an algorithm that runs in O(n) time.
'''
思路：遍历dict，然后每个元素不停+1，更新长度，直到不在dict中
'''
def longestConsecutive(nums: List[int]) -> int:
    # 1.set 查找 O(1)
    # 不需要检查空数组：如果nums为空，set_nums也为空，for循环不执行，直接返回max_length=0
    set_nums = set(nums)
    max_length = 0  # 修复：初始化为0而不是1
    
    for n in set_nums:            # (100 4 200 1 3 2)
        # 2.找sequence头元素
        if n - 1 not in set_nums:
            count = 1
            # 3.search直到consecutive sequence结尾
            cur_n = n
            while cur_n + 1 in set_nums:
                cur_n += 1
                count += 1
            max_length = max(count, max_length)
    
    return max_length

# longestConsecutive([100,4,200,1,3,2])


# ？？？ passed 519 random flip matrix 


# 138 copy list with rand pointer
'''
A linked list of length n is given such that each node contains an additional random pointer, 
which could point to any node in the list, or null.

Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, 
where each new node has its value set to the value of its corresponding original node. 
Both the next and random pointer of the new nodes should point to new nodes in the copied list 
such that the pointers in the original list and copied list represent the same list state. 
None of the pointers in the new list should point to nodes in the original list.
'''
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        pass