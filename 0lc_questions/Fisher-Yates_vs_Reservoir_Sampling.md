# Fisher-Yates 洗牌 vs 蓄水池抽样：本质对比

## 一、算法概述

### ArrayShuffle - Fisher-Yates 洗牌算法
- **目的**：打乱整个数组，生成随机排列
- **输入**：已知长度的数组
- **输出**：打乱后的数组（所有排列等概率）

### LinkedlistShuffle - Reservoir Sampling（蓄水池抽样）
- **目的**：从链表中随机选择一个节点
- **输入**：未知长度的链表（流式数据）
- **输出**：随机选中的一个节点值

---

## 二、本质差异

### 1. 解决的问题不同

| 方面 | Fisher-Yates | Reservoir Sampling |
|------|-------------|-------------------|
| **问题** | 打乱整个数组 | 从流中随机选择一个元素 |
| **输入** | 已知长度的数组 | 未知长度的流/链表 |
| **输出** | 打乱后的数组 | 一个随机元素 |
| **结果数量** | n! 种排列 | n 种可能（每个元素） |

### 2. 算法思路不同

**Fisher-Yates：**
```
对于位置 i (0 到 n-2):
    从 [i, n-1] 中随机选择一个位置 j
    交换 nums[i] 和 nums[j]
```

**Reservoir Sampling：**
```
对于第 i 个元素 (1 到 n):
    以 1/i 的概率选择当前元素
    以 (i-1)/i 的概率保持原有选择
```

### 3. 概率分布不同

**Fisher-Yates：**
- 每个排列的概率 = 1/n!
- 每个元素出现在每个位置的概率 = 1/n
- 结果：n! 种不同的排列

**Reservoir Sampling：**
- 每个元素被选中的概率 = 1/n
- 结果：n 种可能（每个元素）

---

## 三、代码对比

### Fisher-Yates（ArrayShuffle）
```python
def shuffle(self) -> List[int]:
    for i in range(len(self.nums) - 1):
        # 从 [i, n-1] 中随机选择
        r = random.randint(i, len(self.nums) - 1)
        self.nums[i], self.nums[r] = self.nums[r], self.nums[i]
    return self.nums
```

**关键点：**
- 需要知道数组长度 `len(self.nums)`
- 需要能够随机访问（交换操作）
- 修改原数组

### Reservoir Sampling（LinkedlistShuffle）
```python
def getRandom(self) -> int:
    res = 0
    i = 0
    p = self.head
    
    while p != None:
        i += 1
        # 以 1/i 的概率选择当前节点
        rand_num = random.randint(0, i-1)
        if rand_num == 0:
            res = p.val
        p = p.next
    
    return res
```

**关键点：**
- 不需要知道链表长度（流式处理）
- 只需要顺序遍历（不需要随机访问）
- 不修改原链表

---

## 四、应用场景对比

### Fisher-Yates 适用场景：
1. ✅ 打乱数组/列表
2. ✅ 生成随机排列
3. ✅ 洗牌（如扑克牌）
4. ✅ 需要知道数据总长度
5. ✅ 需要随机访问

### Reservoir Sampling 适用场景：
1. ✅ 从流式数据中随机选择
2. ✅ 链表长度未知
3. ✅ 大数据流（无法全部加载到内存）
4. ✅ 只需要顺序访问
5. ✅ 只需要选择一个元素

---

## 五、数学证明对比

### Fisher-Yates：每个排列概率 = 1/n!

**证明思路：**
- 第1个位置：n 种选择，每个元素概率 = 1/n
- 第2个位置：n-1 种选择，每个元素概率 = 1/(n-1)
- ...
- 第n个位置：1 种选择，概率 = 1/1

总概率 = (1/n) × (1/(n-1)) × ... × (1/1) = 1/n!

### Reservoir Sampling：每个元素概率 = 1/n

**证明思路：**
- 第 i 个元素被选中 = 在第 i 步选中 × 后续都不替换
- P(第i个) = (1/i) × (1-1/(i+1)) × ... × (1-1/n)
- = (1/i) × (i/(i+1)) × ... × ((n-1)/n) = 1/n

---

## 六、相同点

虽然本质不同，但它们有一些相似之处：

1. **都使用随机性**：都依赖随机数生成
2. **都保证均匀分布**：Fisher-Yates 保证排列均匀，Reservoir Sampling 保证元素均匀
3. **都是 O(n) 时间复杂度**：都需要遍历所有元素
4. **都使用"动态概率"思想**：
   - Fisher-Yates：每个位置从剩余元素中选择
   - Reservoir Sampling：每个元素以动态概率被选择

---

## 七、核心区别总结

| 维度 | Fisher-Yates | Reservoir Sampling |
|------|-------------|-------------------|
| **本质** | 生成随机排列 | 随机选择一个元素 |
| **需要长度** | ✅ 是 | ❌ 否（流式） |
| **需要随机访问** | ✅ 是（交换） | ❌ 否（顺序遍历） |
| **修改原数据** | ✅ 是 | ❌ 否 |
| **结果数量** | n! 种排列 | n 种可能 |
| **概率分布** | 每个排列 1/n! | 每个元素 1/n |

---

## 八、结论

**这两个算法的本质不同：**

1. **Fisher-Yates** 是"排列生成"算法，用于打乱整个数组
2. **Reservoir Sampling** 是"抽样"算法，用于从流中随机选择一个元素

虽然它们都涉及随机性和概率，但：
- 解决的问题不同
- 算法思路不同
- 应用场景不同
- 概率分布不同

**相似之处**：都使用了"动态概率"的思想，但应用方式不同。

---

## 九、类比理解

**Fisher-Yates** 就像：
- 洗一副牌：把所有牌打乱，生成一个随机排列
- 需要知道牌的总数
- 可以随机交换任意两张牌

**Reservoir Sampling** 就像：
- 从传送带上随机选一个产品：产品一个接一个来，不知道总数
- 只能看当前产品，不能回头看
- 最终随机选一个产品

两者解决的问题完全不同！


