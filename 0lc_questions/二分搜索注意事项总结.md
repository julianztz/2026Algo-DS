# 二分搜索注意事项总结

## 一、核心模板

### 模板1：标准二分搜索（查找精确值）

```python
def binarySearch(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:  # ⚠️ 注意：<= 不是 <
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1   # ⚠️ 注意：+1，跳过mid
        else:
            right = mid - 1  # ⚠️ 注意：-1，跳过mid
    
    return -1  # 未找到
```

### 模板2：查找插入位置（Search Insert Position）

```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            return mid
    
    return left  # ⚠️ 注意：返回 left，不是 right
```

### 模板3：查找边界（左边界/右边界）

```python
# 查找左边界（第一个 >= target 的位置）
def findLeftBound(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1  # ⚠️ 注意：即使相等也继续向左搜索
    
    return left  # 左边界

# 查找右边界（最后一个 <= target 的位置）
def findRightBound(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] <= target:
            left = mid + 1   # ⚠️ 注意：即使相等也继续向右搜索
        else:
            right = mid - 1
    
    return right  # 右边界
```

---

## 二、关键注意事项

### 1. 循环条件：`left <= right` vs `left < right`

**`left <= right`（推荐）**：
- 适用于：查找精确值、查找插入位置
- 循环结束时：`left > right`，此时 `left` 是插入位置
- 优点：逻辑清晰，不容易出错

**`left < right`**：
- 适用于：查找边界、某些特殊场景
- 循环结束时：`left == right`，需要额外判断
- 缺点：容易出错，需要额外处理

**建议**：优先使用 `left <= right`

### 2. 指针移动：必须跳过 mid

**❌ 错误**：
```python
if nums[mid] < target:
    left = mid  # 错误！没有跳过 mid，可能导致死循环
```

**✅ 正确**：
```python
if nums[mid] < target:
    left = mid + 1  # 正确！跳过 mid，避免死循环
```

**原因**：
- 如果 `left = mid`，当 `left == right` 时，`mid = (left + right) // 2 = left`，导致 `left` 不变，死循环
- 必须跳过 `mid`，确保每次循环都能缩小搜索范围

### 3. 返回值：根据问题选择

| 问题类型 | 返回值 | 说明 |
|---------|--------|------|
| 查找精确值 | `mid` 或 `-1` | 找到返回索引，未找到返回 -1 |
| 查找插入位置 | `left` | 循环结束时，`left` 是插入位置 |
| 查找左边界 | `left` | 第一个 >= target 的位置 |
| 查找右边界 | `right` | 最后一个 <= target 的位置 |

### 4. 整数溢出问题

**问题**：`mid = (left + right) // 2` 可能溢出（Python 不会，但其他语言会）

**解决方案**：
```python
# 方法1：使用位运算（推荐）
mid = (left + right) >> 1

# 方法2：避免溢出
mid = left + (right - left) // 2
```

### 5. 边界情况处理

**空数组**：
```python
if not nums:
    return -1
```

**单元素数组**：
```python
if len(nums) == 1:
    return 0 if nums[0] == target else -1
```

**目标值在边界**：
- 确保 `left` 和 `right` 的初始值正确
- `left = 0`，`right = len(nums) - 1`（包含两端）

### 6. 2D 矩阵的二分搜索

**索引映射**：
```python
# 线性索引 -> 2D 位置
row = linear_idx // col
col = linear_idx % col

# 2D 位置 -> 线性索引
linear_idx = row * col + col
```

**注意**：
- 不需要展平矩阵（会浪费空间）
- 直接计算索引映射，时间复杂度 O(log(m*n))，空间复杂度 O(1)

---

## 三、常见错误

### 错误1：循环条件错误

```python
# ❌ 错误
while left < right:  # 可能漏掉 left == right 的情况
    ...

# ✅ 正确
while left <= right:  # 包含所有情况
    ...
```

### 错误2：指针移动错误

```python
# ❌ 错误
if nums[mid] < target:
    left = mid  # 没有跳过 mid，可能死循环

# ✅ 正确
if nums[mid] < target:
    left = mid + 1  # 跳过 mid
```

### 错误3：返回值错误

```python
# ❌ 错误（查找插入位置）
return right  # 应该返回 left

# ✅ 正确
return left  # left 是插入位置
```

### 错误4：边界处理错误

```python
# ❌ 错误
right = len(nums)  # 超出范围

# ✅ 正确
right = len(nums) - 1  # 最后一个有效索引
```

---

## 四、二分搜索的变种

### 1. 在答案空间上二分（如 Koko Eating Bananas）

```python
def minEatingSpeed(piles, h):
    left = 1
    right = max(piles)
    
    while left <= right:
        mid = (left + right) // 2
        
        if canFinish(piles, mid, h):
            right = mid - 1  # 尝试更小的速度
        else:
            left = mid + 1  # 需要更大的速度
    
    return left
```

**关键点**：
- 在答案空间上二分，而不是在数组上二分
- 需要设计判断函数 `canFinish()`

### 2. 查找旋转排序数组

```python
def searchRotated(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        # 判断哪一半是有序的
        if nums[left] <= nums[mid]:  # 左半部分有序
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # 右半部分有序
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

---

## 五、调试技巧

### 1. 打印中间状态

```python
while left <= right:
    mid = (left + right) // 2
    print(f"left={left}, right={right}, mid={mid}, nums[mid]={nums[mid]}")
    ...
```

### 2. 检查循环是否会终止

- 确保每次循环都能缩小搜索范围
- 确保 `left` 和 `right` 会变化
- 确保不会出现 `left == right == mid` 的死循环

### 3. 验证边界情况

- 空数组
- 单元素数组
- 目标值在第一个位置
- 目标值在最后一个位置
- 目标值不存在

---

## 六、200字核心总结

二分搜索的核心是"每次排除一半"。关键注意事项：1) 循环条件用 `left <= right`，确保不遗漏；2) 指针移动必须跳过 mid（`left = mid + 1` 或 `right = mid - 1`），避免死循环；3) 返回值根据问题选择：查找精确值返回 `mid`，查找插入位置返回 `left`，查找边界返回 `left` 或 `right`；4) 处理边界：空数组、单元素、目标在边界；5) 整数溢出用 `left + (right - left) // 2`；6) 2D 矩阵用索引映射 `row = idx // col, col = idx % col`，避免展平。常见错误：循环条件用 `<`、指针移动不跳过 mid、返回值选错。记住：二分搜索的本质是"缩小搜索范围"，每次必须排除 mid，确保范围缩小。



