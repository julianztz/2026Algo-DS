# -*- coding: utf-8 -*-
"""
单调栈详解 - 下一个更大元素问题
"""

import sys
import io

if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# 你的实现
def calculateGreaterElement(nums):
    n = len(nums)
    # 存放答案的数组
    res = [0] * n
    s = []
    # 倒着往栈里放
    for i in range(n-1, -1, -1):
        # 判定个子高矮
        while s and s[-1] <= nums[i]:
            # 矮个起开，反正也被挡着了。。。
            s.pop()
        # nums[i] 身后的更大元素
        res[i] = -1 if not s else s[-1]
        s.append(nums[i])
    return res


print("=" * 70)
print("单调栈详解：下一个更大元素问题")
print("=" * 70)

print("""
【问题描述】
输入一个数组 nums，要求返回一个等长的结果数组，
结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1

例如：
  nums = [2, 1, 2, 4, 3, 1]
  结果 = [4, 2, 4, -1, -1, -1]
  
  解释：
  - nums[0]=2 的下一个更大元素是 4（在索引3）
  - nums[1]=1 的下一个更大元素是 2（在索引2）
  - nums[2]=2 的下一个更大元素是 4（在索引3）
  - nums[3]=4 没有下一个更大元素 → -1
  - nums[4]=3 没有下一个更大元素 → -1
  - nums[5]=1 没有下一个更大元素 → -1
""")

print("\n" + "=" * 70)
print("1. 什么是单调栈？")
print("=" * 70)

print("""
单调栈：栈内元素保持单调性（单调递增或单调递减）

在这个问题中：
  - 我们维护一个单调递减栈（从栈底到栈顶递减）
  - 栈中存储的是"候选答案"（可能是某个元素的下一个更大元素）
  - 当新元素入栈时，移除所有比它小的元素（因为它们不可能成为答案）
""")

print("\n" + "=" * 70)
print("2. 为什么从后往前遍历？")
print("=" * 70)

print("""
关键理解：我们需要找"下一个"更大元素，即"右边"的第一个更大元素

从后往前遍历的好处：
  1. 当我们处理 nums[i] 时，栈中已经存储了 i 之后的所有元素
  2. 栈顶元素就是 nums[i] 右边最近的元素
  3. 如果栈顶 <= nums[i]，说明栈顶不可能成为 nums[i] 的答案
     （因为 nums[i] 会"挡住"栈顶，后面的元素看不到栈顶）
  4. 移除这些"被挡住"的元素，保持栈的单调性
""")

print("\n" + "=" * 70)
print("3. 算法步骤详解")
print("=" * 70)

print("""
步骤1: 从后往前遍历数组
步骤2: 对于每个元素 nums[i]：
  a. 移除栈中所有 <= nums[i] 的元素（这些元素被 nums[i] 挡住了）
  b. 如果栈为空，说明没有更大元素 → res[i] = -1
  c. 如果栈不为空，栈顶就是下一个更大元素 → res[i] = s[-1]
  d. 将 nums[i] 入栈（作为后续元素的候选答案）

关键点：
  - 栈中存储的是"候选答案"（可能是某个元素的下一个更大元素）
  - 维护单调递减栈，保证栈顶是"最近的"候选答案
  - 移除被挡住的元素，因为它们不可能成为答案
""")

print("\n" + "=" * 70)
print("4. 可视化演示")
print("=" * 70)

def visualize_process(nums):
    print(f"\n输入数组: {nums}")
    print("\n执行过程：")
    print("-" * 70)
    
    n = len(nums)
    res = [-1] * n
    s = []
    
    for i in range(n-1, -1, -1):
        print(f"\n处理索引 {i}, 元素 nums[{i}] = {nums[i]}")
        print(f"  当前栈: {s}")
        
        # 移除被挡住的元素
        removed = []
        while s and s[-1] <= nums[i]:
            removed.append(s.pop())
        if removed:
            print(f"  移除被挡住的元素: {removed} (因为 {nums[i]} 挡住了它们)")
        
        # 确定答案
        if not s:
            res[i] = -1
            print(f"  栈为空 → res[{i}] = -1")
        else:
            res[i] = s[-1]
            print(f"  栈顶是下一个更大元素 → res[{i}] = {s[-1]}")
        
        # 入栈
        s.append(nums[i])
        print(f"  将 {nums[i]} 入栈")
        print(f"  更新后的栈: {s}")
    
    print("\n" + "-" * 70)
    print(f"最终结果: {res}")
    return res

# 演示
nums1 = [2, 1, 2, 4, 3, 1]
visualize_process(nums1)

print("\n" + "=" * 70)
print("5. 为什么维护单调递减栈？")
print("=" * 70)

print("""
单调递减栈（从栈底到栈顶递减）的含义：
  - 栈底：较早处理的元素（在数组右边）
  - 栈顶：最近处理的元素（在数组右边，更靠近当前位置）
  
当我们处理 nums[i] 时：
  - 如果栈顶 <= nums[i]，说明栈顶被 nums[i] 挡住了
  - 后面的元素（在 i 左边）看不到栈顶，所以栈顶不可能成为答案
  - 移除栈顶，继续检查下一个
  - 直到找到 > nums[i] 的元素，或者栈为空

这样保证了：
  - 栈顶始终是"最近的"候选答案
  - 栈中元素按从右到左的顺序排列
  - 栈顶是第一个（最近的）可能成为答案的元素
""")

print("\n" + "=" * 70)
print("6. 时间复杂度分析")
print("=" * 70)

print("""
时间复杂度：O(n)
  - 每个元素最多入栈一次、出栈一次
  - 虽然内层有 while 循环，但每个元素最多被移除一次
  - 总体是 O(n)

空间复杂度：O(n)
  - 栈最多存储 n 个元素
  - 结果数组需要 O(n) 空间
""")

print("\n" + "=" * 70)
print("7. 其他变种问题")
print("=" * 70)

print("""
【变种1：下一个更小元素】
  只需改变比较条件：while s and s[-1] >= nums[i]:

【变种2：上一个更大元素】
  改为从前往后遍历，其他逻辑相同

【变种3：上一个更小元素】
  从前往后遍历 + 改变比较条件

【变种4：循环数组】
  遍历两遍数组，或者使用取模运算
""")

print("\n" + "=" * 70)
print("8. 测试更多例子")
print("=" * 70)

test_cases = [
    [2, 1, 2, 4, 3, 1],
    [1, 2, 3, 4, 5],
    [5, 4, 3, 2, 1],
    [3, 1, 4, 2],
    [1, 3, 4, 2],
]

for nums in test_cases:
    result = calculateGreaterElement(nums)
    print(f"\n输入: {nums}")
    print(f"输出: {result}")

print("\n" + "=" * 70)
print("9. 关键理解总结")
print("=" * 70)

print("""
✅ 单调栈的核心思想：
  1. 维护一个单调栈（递增或递减）
  2. 利用栈的"后进先出"特性
  3. 移除不可能成为答案的元素

✅ 这个问题的关键：
  1. 从后往前遍历（因为要找"下一个"，即"右边"的）
  2. 维护单调递减栈（栈顶是最近的候选答案）
  3. 移除被挡住的元素（<= nums[i] 的元素）

✅ 记忆技巧：
  - "下一个更大" → 从后往前 + 单调递减栈
  - "上一个更大" → 从前往后 + 单调递减栈
  - "下一个更小" → 从后往前 + 单调递增栈
  - "上一个更小" → 从前往后 + 单调递增栈
""")






























