# Pop操作树形结构可视化详解

## 输入数据
`nums = [1, 3, 2, 5, 6, 4]`

---

## 初始堆（Push完所有元素后）

### 数组表示
```
[1, 3, 2, 5, 6, 4]
```

### 树形结构
```
        1
       / \
      3   2
     / \ /
    5  6 4
```

**说明**：
- 堆顶（根节点）是 `1`（最小值）
- 满足最小堆性质：`parent ≤ children`
- 索引映射：
  - 0: 1（根）
  - 1: 3（左子）
  - 2: 2（右子）
  - 3: 5（左子的左子）
  - 4: 6（左子的右子）
  - 5: 4（右子的左子）

---

## Pop操作：每一步的树形结构变化

### 【Pop 1】弹出值: 1

**操作过程**：
1. 取出堆顶 `1`
2. 用最后一个元素 `4` 替换堆顶
3. 执行 **sink（下沉）** 操作：
   - `4` vs `3, 2` → `4 > 2`，交换 `4` 和 `2`
   - `4` vs `6` → `4 < 6`，停止

**结果**：

#### 数组表示
```
[2, 3, 4, 5, 6]
```

#### 树形结构
```
        2
       / \
      3   4
     / \
    5   6
```

**说明**：
- 新堆顶是 `2`（当前最小值）
- 堆结构已重新调整
- `4` 从底部移到了合适位置

---

### 【Pop 2】弹出值: 2

**操作过程**：
1. 取出堆顶 `2`
2. 用最后一个元素 `6` 替换堆顶
3. 执行 **sink（下沉）** 操作：
   - `6` vs `3, 4` → `6 > 3` 且 `6 > 4`，与较小值 `3` 交换
   - 继续：`6` vs `5` → `6 > 5`，交换
   - `6` vs 无子节点，停止

**结果**：

#### 数组表示
```
[3, 5, 4, 6]
```

#### 树形结构
```
        3
       / \
      5   4
     /
    6
```

**说明**：
- 新堆顶是 `3`（当前最小值）
- `6` 下沉到了左子树底部

---

### 【Pop 3】弹出值: 3

**操作过程**：
1. 取出堆顶 `3`
2. 用最后一个元素 `6` 替换堆顶
3. 执行 **sink（下沉）** 操作：
   - `6` vs `5, 4` → `6 > 5` 且 `6 > 4`，与较小值 `4` 交换
   - `6` 成为叶子节点，停止

**结果**：

#### 数组表示
```
[4, 5, 6]
```

#### 树形结构
```
        4
       / \
      5   6
```

**说明**：
- 新堆顶是 `4`（当前最小值）
- 树结构变成完整的二叉树

---

### 【Pop 4】弹出值: 4

**操作过程**：
1. 取出堆顶 `4`
2. 用最后一个元素 `6` 替换堆顶
3. 执行 **sink（下沉）** 操作：
   - `6` vs `5` → `6 > 5`，交换
   - `6` 成为叶子节点，停止

**结果**：

#### 数组表示
```
[5, 6]
```

#### 树形结构
```
        5
       /
      6
```

**说明**：
- 新堆顶是 `5`（当前最小值）
- 只剩下两个节点

---

## 总结

### 弹出顺序
```
[1, 2, 3, 4]
```

**验证**：每次pop都是当前堆中的最小值，符合min heap的性质。

### 最终状态
- **剩余堆**：`[5, 6]`
- **堆顶**：`5`（最小值）
- **已弹出**：`[1, 2, 3, 4]`

### 关键观察

1. **每次pop都是最小值**
   - Pop 1: 弹出 `1`
   - Pop 2: 弹出 `2`
   - Pop 3: 弹出 `3`
   - Pop 4: 弹出 `4`

2. **自动重新调整**
   - 每次pop后，heapq自动执行 **sink（下沉）** 操作
   - 保证堆性质：`parent ≤ children`
   - 新的堆顶总是当前的最小值

3. **时间复杂度**
   - 每次pop: O(log n)
   - 因为需要下沉调整堆结构

---

## 堆的数组索引映射规则

对于索引 `i`：
- **左子节点**：`2*i + 1`
- **右子节点**：`2*i + 2`
- **父节点**：`(i-1) // 2`

### 示例：初始堆 `[1, 3, 2, 5, 6, 4]`

| 索引 | 值 | 父节点索引 | 左子索引 | 右子索引 |
|------|-----|-----------|---------|---------|
| 0 | 1 | - | 1 | 2 |
| 1 | 3 | 0 | 3 | 4 |
| 2 | 2 | 0 | 5 | - |
| 3 | 5 | 1 | - | - |
| 4 | 6 | 1 | - | - |
| 5 | 4 | 2 | - | - |

---

## 可视化代码

运行 `visualize_heap_pop.py` 可以看到完整的可视化过程：
```bash
python3 Heap&PriorityQ/visualize_heap_pop.py
```


















