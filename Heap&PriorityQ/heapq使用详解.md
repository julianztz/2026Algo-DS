# heapq 使用详解

## 问题1：默认heapq是minHeap（头小子大）吗？

### ✅ **答案：是的！**

`heapq` 默认实现的是**最小堆（min heap）**，即：
- **堆顶元素（root）是最小值**
- 满足堆性质：`parent ≤ children`（对于所有节点）
- 堆顶可以通过 `heap[0]` 访问，时间复杂度 O(1)

### 验证代码：
```python
import heapq

heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappush(heap, 8)
heapq.heappush(heap, 1)

print(heap)        # [1, 2, 8, 5]
print(heap[0])     # 1（最小值在堆顶）
```

### 如何实现最大堆？

由于 `heapq` 只支持最小堆，要实现最大堆有两种方法：

**方法1：插入负值**
```python
import heapq

# 最大堆：插入时取负
max_heap = []
nums = [3, 1, 4, 1, 5]
for num in nums:
    heapq.heappush(max_heap, -num)  # 插入负值

# 弹出时再取负
max_val = -heapq.heappop(max_heap)  # 得到真正的最大值
```

**方法2：使用自定义比较函数**
```python
import heapq

# 使用元组 (priority, value)
heap = []
heapq.heappush(heap, (-5, 5))  # 优先级取负，实现最大堆
heapq.heappush(heap, (-2, 2))
heapq.heappush(heap, (-8, 8))

max_val = heapq.heappop(heap)[1]  # 取出值部分
```

---

## 问题2：heappop每次都会选取当前tree中最小元素（root node）吗？删除以后会自动reshape tree成为一个min binary heap？

### ✅ **答案：是的！**

1. **heappop总是返回并删除堆顶元素（最小值）**
2. **删除后会自动重新调整堆结构（heapify）**，保证堆性质

### 工作原理：

#### **heappop的步骤：**
1. 取出堆顶元素 `heap[0]`（最小值）
2. 将最后一个元素 `heap[-1]` 移到堆顶
3. 执行 **sink（下沉）** 操作：
   - 比较当前节点与左右子节点
   - 如果当前节点大于某个子节点，交换它们
   - 重复直到满足堆性质（`parent ≤ children`）

#### **示例演示：**

```
初始heap: [1, 3, 2, 5, 6, 4]
树形结构：
        1
       / \
      3   2
     / \ /
    5  6 4

Pop 1:
1. 取出1，用最后一个元素4替换
   [4, 3, 2, 5, 6]
2. 4下沉（sink）：
   4 vs 3, 2 → 4 > 2，交换4和2
   [2, 3, 4, 5, 6]
3. 4 vs 6 → 4 < 6，停止

最终: [2, 3, 4, 5, 6]
```

### 时间复杂度：
- **heappop**: O(log n) - 因为需要下沉调整堆结构
- **heap[0]**: O(1) - 访问堆顶

---

## 问题3：一般heap可以直接用吗？不需要手动编写push和pop之后heap的变化？

### ✅ **答案：是的！可以直接使用，不需要手动实现。**

`heapq` 模块已经实现了所有堆操作，包括：
- `heappush(heap, item)` - 插入元素，自动调整
- `heappop(heap)` - 弹出最小元素，自动调整
- `heapify(x)` - 将列表转换为堆，O(n)时间
- `heappushpop(heap, item)` - 先push再pop，更高效
- `heapreplace(heap, item)` - 先pop再push

### 你只需要：
1. **导入模块**：`import heapq`
2. **创建列表**：`heap = []`
3. **使用函数**：`heapq.heappush(heap, item)`，`heapq.heappop(heap)`

### ⚠️ **注意事项：**

1. **必须使用 heapq 的函数**
   ```python
   # ❌ 错误：直接用list.append
   heap = []
   heap.append(3)  # 这不会维护堆性质！
   
   # ✅ 正确：使用heappush
   heap = []
   heapq.heappush(heap, 3)  # 自动维护堆性质
   ```

2. **堆的数组表示**
   - Python的heap是用**数组**实现的完全二叉树
   - 对于索引 `i`：
     - 左子节点：`2*i + 1`
     - 右子节点：`2*i + 2`
     - 父节点：`(i-1) // 2`

3. **heapq不检查堆性质**
   - 如果你手动修改了列表，需要调用 `heapq.heapify(heap)` 重新调整

---

## 详细示例：每次push和pop后的heap状态

### 输入：`nums = [1, 3, 2, 5, 6, 4]`

#### **Push操作（构建堆）**

| 步骤 | 操作 | 堆的数组表示 | 堆顶 | 树形结构（简化） |
|------|------|------------|------|----------------|
| 初始 | - | `[]` | - | 空 |
| 1 | Push 1 | `[1]` | 1 | `1` |
| 2 | Push 3 | `[1, 3]` | 1 | ```
      1
     /
    3``` |
| 3 | Push 2 | `[1, 3, 2]` | 1 | ```
      1
     / \
    3   2``` |
| 4 | Push 5 | `[1, 3, 2, 5]` | 1 | ```
      1
     / \
    3   2
   /
  5``` |
| 5 | Push 6 | `[1, 3, 2, 5, 6]` | 1 | ```
      1
     / \
    3   2
   / \
  5   6``` |
| 6 | Push 4 | `[1, 3, 2, 5, 6, 4]` | 1 | ```
      1
     / \
    3   2
   / \ /
  5  6 4``` |

**说明**：
- 每次push后，新元素会执行 **swim（上浮）** 操作
- 保证堆性质：`parent ≤ children`
- 堆顶始终是最小值 `1`

#### **Pop操作（直到只剩2个元素）**

| 步骤 | 操作 | 弹出值 | 剩余堆 | 堆顶 | 说明 |
|------|------|--------|--------|------|------|
| 初始 | - | - | `[1, 3, 2, 5, 6, 4]` | 1 | - |
| 7 | Pop | **1** | `[2, 3, 4, 5, 6]` | 2 | 用4替换1，然后4下沉与2交换 |
| 8 | Pop | **2** | `[3, 5, 4, 6]` | 3 | 用6替换2，然后6下沉与3交换，再与4交换 |
| 9 | Pop | **3** | `[4, 5, 6]` | 4 | 用6替换3，然后6下沉 |
| 10 | Pop | **4** | `[5, 6]` | 5 | 用6替换4，堆调整完成 |

**详细说明Pop 1的过程：**
```
初始: [1, 3, 2, 5, 6, 4]
树形：
        1
       / \
      3   2
     / \ /
    5  6 4

步骤1: 取出堆顶1
步骤2: 用最后一个元素4替换堆顶
      [4, 3, 2, 5, 6]
      4
     / \
    3   2
   / \
  5   6

步骤3: 4下沉（sink）
      - 4 vs 3, 2 → 4 > 2，交换4和2
      [2, 3, 4, 5, 6]
      2
     / \
    3   4
   / \
  5   6

步骤4: 4 vs 6 → 4 < 6，停止下沉
最终: [2, 3, 4, 5, 6]
```

---

## 核心总结

### ✅ **问题1答案：**
- `heapq` 默认是 **min heap（最小堆）**
- 堆顶元素是最小值，可通过 `heap[0]` 访问

### ✅ **问题2答案：**
- `heappop` 总是返回并删除**堆顶元素（最小值）**
- 删除后**自动执行heapify（下沉操作）**，重新调整堆结构
- 时间复杂度：O(log n)

### ✅ **问题3答案：**
- **可以直接使用**，不需要手动实现push/pop的逻辑
- `heapq` 模块已经实现了所有堆操作
- 只需要调用 `heappush` 和 `heappop` 函数即可

### 📝 **使用模板：**

```python
import heapq

# 创建堆
heap = []

# 插入元素（自动调整）
for num in nums:
    heapq.heappush(heap, num)

# 弹出最小元素（自动调整）
while heap:
    min_val = heapq.heappop(heap)
    print(min_val)

# 访问堆顶（不删除）
if heap:
    top = heap[0]  # O(1)
```

---

## 进阶：理解堆的内部实现

### 数组表示 vs 树形结构

堆可以用数组表示完全二叉树：
- 索引 `0`：根节点
- 索引 `i` 的左子节点：`2*i + 1`
- 索引 `i` 的右子节点：`2*i + 2`
- 索引 `i` 的父节点：`(i-1) // 2`

### 关键操作：

1. **Swim（上浮）**：插入元素时，从底部向上调整
2. **Sink（下沉）**：删除元素时，从顶部向下调整

这些操作都由 `heapq` 自动处理，你不需要手动实现！


















