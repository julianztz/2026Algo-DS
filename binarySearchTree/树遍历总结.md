# 二叉树和多叉树遍历总结

## 一、二叉树（Binary Tree）

### 1. DFS 遍历（递归）

#### 前序遍历（Preorder）：根 -> 左 -> 右
```python
def preorder(root: Optional[TreeNode]) -> None:
    if not root:
        return
    print(root.val)          # 前序位置：访问当前节点
    preorder(root.left)
    preorder(root.right)
```

#### 中序遍历（Inorder）：左 -> 根 -> 右
```python
def inorder(root: Optional[TreeNode]) -> None:
    if not root:
        return
    inorder(root.left)
    print(root.val)          # 中序位置：访问当前节点
    inorder(root.right)
```

#### 后序遍历（Postorder）：左 -> 右 -> 根
```python
def postorder(root: Optional[TreeNode]) -> List:
    result = []
    def traverse(node):
        if not node:
            return
        traverse(node.left)
        traverse(node.right)
        result.append(node.val)  # 后序位置：访问当前节点
    traverse(root)
    return result
```

**关键点：**
- **前序**：访问节点时只有当前节点信息
- **中序**：访问节点时已有左子树信息
- **后序**：访问节点时已有左右子树信息（常用于DP思路）

### 2. DFS 遍历（迭代 - 栈）

#### 前序遍历（迭代）
```python
def preorder_iterative(root: Optional[TreeNode]) -> List:
    if not root:
        return []
    res = []
    stack = [root]
    while stack:
        node = stack.pop()
        res.append(node.val)
        if node.right:  # 先右后左，保证出栈时左先出
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    return res
```

#### 中序遍历（迭代）
```python
def inorder_iterative(root: Optional[TreeNode]) -> List:
    res = []
    stack = []
    cur = root
    while cur or stack:
        while cur:  # 一直向左走到底
            stack.append(cur)
            cur = cur.left
        cur = stack.pop()
        res.append(cur.val)
        cur = cur.right
    return res
```

#### 后序遍历（迭代）
```python
def postorder_iterative(root: Optional[TreeNode]) -> List:
    if not root:
        return []
    res = []
    stack = [root]
    while stack:
        node = stack.pop()
        res.append(node.val)
        if node.left:  # 先左后右，最后反转结果
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
    return res[::-1]  # 反转：根右左 -> 左右根
```

### 3. BFS 遍历（层序遍历）

#### 基础层序遍历
```python
def levelOrder(root: Optional[TreeNode]) -> None:
    if not root:
        return
    q = deque([root])
    while q:
        cur = q.popleft()
        print(cur.val)
        if cur.left:
            q.append(cur.left)
        if cur.right:
            q.append(cur.right)
```

#### 按层分组（记录层数）
```python
def levelOrder2(root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
        return []
    res = []
    q = deque([root])
    while q:
        level_size = len(q)  # 当前层的节点数
        level_nodes = []
        for _ in range(level_size):
            cur = q.popleft()
            level_nodes.append(cur.val)
            if cur.left:
                q.append(cur.left)
            if cur.right:
                q.append(cur.right)
        res.append(level_nodes)
    return res
```

---

## 二、多叉树（N-ary Tree）

### 节点定义
```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []
```

### 1. DFS 遍历（递归）

#### 前序遍历
```python
def preorder_nary(root: Optional[Node]) -> List[int]:
    res = []
    def traverse(node):
        if not node:
            return
        res.append(node.val)  # 前序位置
        for child in node.children:
            traverse(child)
    traverse(root)
    return res
```

#### 后序遍历
```python
def postorder_nary(root: Optional[Node]) -> List[int]:
    res = []
    def traverse(node):
        if not node:
            return
        for child in node.children:
            traverse(child)
        res.append(node.val)  # 后序位置
    traverse(root)
    return res
```

**注意：** 多叉树没有中序遍历（因为无法定义"中间"）

### 2. DFS 遍历（迭代 - 栈）

#### 前序遍历（迭代）
```python
def preorder_nary_iterative(root: Optional[Node]) -> List[int]:
    if not root:
        return []
    res = []
    stack = [root]
    while stack:
        node = stack.pop()
        res.append(node.val)
        # 从右到左入栈，保证从左到右出栈
        for child in reversed(node.children):
            stack.append(child)
    return res
```

#### 后序遍历（迭代）
```python
def postorder_nary_iterative(root: Optional[Node]) -> List[int]:
    if not root:
        return []
    res = []
    stack = [root]
    while stack:
        node = stack.pop()
        res.append(node.val)
        # 从左到右入栈，最后反转结果
        for child in node.children:
            stack.append(child)
    return res[::-1]
```

### 3. BFS 遍历（层序遍历）

#### 基础层序遍历
```python
def levelOrder_nary(root: Optional[Node]) -> List[int]:
    if not root:
        return []
    res = []
    q = deque([root])
    while q:
        cur = q.popleft()
        res.append(cur.val)
        for child in cur.children:
            q.append(child)
    return res
```

#### 按层分组
```python
def levelOrder_nary_grouped(root: Optional[Node]) -> List[List[int]]:
    if not root:
        return []
    res = []
    q = deque([root])
    while q:
        level_size = len(q)
        level_nodes = []
        for _ in range(level_size):
            cur = q.popleft()
            level_nodes.append(cur.val)
            for child in cur.children:
                q.append(child)
        res.append(level_nodes)
    return res
```

---

## 三、模板总结

### DFS 递归模板（通用）
```python
def dfs(node):
    # 1. Base case
    if not node:
        return
    
    # 2. 前序位置：访问节点
    # process(node)
    
    # 3. 递归子节点
    for child in get_children(node):
        dfs(child)
    
    # 4. 后序位置：访问节点
    # process(node)
```

### DFS 迭代模板（栈）
```python
def dfs_iterative(root):
    if not root:
        return []
    res = []
    stack = [root]
    while stack:
        node = stack.pop()
        # 处理节点
        res.append(node.val)
        # 子节点入栈（注意顺序）
        for child in get_children(node):
            stack.append(child)
    return res
```

### BFS 模板（队列）
```python
def bfs(root):
    if not root:
        return []
    q = deque([root])
    while q:
        # 按层处理
        level_size = len(q)
        for _ in range(level_size):
            cur = q.popleft()
            # 处理节点
            process(cur)
            # 子节点入队
            for child in get_children(cur):
                q.append(child)
```

---

## 四、选择指南

### 何时用 DFS（递归）？
- 需要利用子树信息（后序遍历）
- 需要回溯（前序进入，后序离开）
- 逻辑清晰，代码简洁

### 何时用 DFS（迭代）？
- 避免栈溢出（树很深）
- 需要控制遍历顺序
- 需要提前终止遍历

### 何时用 BFS？
- 需要按层处理
- 找最短路径（层数 = 路径长度）
- 需要找到第一个满足条件的节点（如最小深度）

### 前中后序的选择？
- **前序**：复制树、序列化、打印路径
- **中序**：BST 中序遍历得到有序序列
- **后序**：计算子树信息、删除节点、计算路径和

---

## 五、递归 vs 迭代：哪个更常见？

### **递归更常见（90%+ 的情况）**

**原因：**

1. **代码简洁清晰**
   ```python
   # 递归：3行核心代码
   def dfs(node):
       if not node: return
       process(node)
       dfs(node.left)
       dfs(node.right)
   
   # 迭代：需要维护栈，代码更长
   def dfs_iterative(node):
       stack = [node]
       while stack:
           cur = stack.pop()
           if not cur: continue
           process(cur)
           stack.append(cur.right)
           stack.append(cur.left)
   ```

2. **思维模式匹配**
   - 递归天然符合"分治"和"回溯"思维
   - 前序/中序/后序位置清晰，便于在不同位置处理逻辑
   - 子树信息传递直观（返回值）

3. **LeetCode 和面试中的实际情况**
   - 绝大多数题目用递归都能解决
   - 面试官更关注算法思路，而非实现细节
   - 递归代码更容易解释和调试

4. **实际应用场景**
   - 计算树的高度、节点数、直径等（后序遍历）
   - 路径问题、回溯问题（前序进入，后序离开）
   - 验证BST、序列化/反序列化等

### **迭代更常见的情况（<10%）**

**何时必须用迭代：**

1. **栈溢出风险**
   - 树非常深（如链表化的树，深度 = 节点数）
   - Python 默认递归深度约 1000 层
   - 生产环境可能限制更严格

2. **性能要求极高**
   - 需要精确控制内存使用
   - 避免函数调用开销（虽然现代编译器优化后差异不大）

3. **特定算法需求**
   - Morris 遍历（O(1) 空间复杂度）
   - 需要暂停/恢复遍历状态
   - 需要手动管理遍历栈

### **实际建议**

**优先使用递归，除非：**
- 明确要求 O(1) 空间复杂度
- 树深度可能超过 1000 层
- 面试官明确要求迭代实现

**面试策略：**
1. 先用递归实现（快速、清晰）
2. 如果面试官问"能否用迭代？"，再展示迭代版本
3. 说明两种方法的优缺点

### **统计参考**

根据 LeetCode 热门题目统计：
- **递归解法**：约 85-90%
- **迭代解法**：约 10-15%
- **BFS（层序遍历）**：约 20-30%（很多题目需要按层处理）

**结论：你的观察是正确的！递归确实是二叉树 DFS 的主流方法。**

