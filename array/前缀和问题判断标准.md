# 前缀和（Prefix Sum）问题判断标准

！！！！！！ 累计问题  ！！！！！

## 一、前缀和的核心特点

### 1. 基本原理
- **前缀和数组**：`preSum[i] = sum(nums[0...i-1])`
- **区间查询**：`sum(nums[i...j]) = preSum[j+1] - preSum[i]`
- **O(1) 查询**：将区间和查询从 O(n) 优化到 O(1)

### 2. 时间复杂度优势
- **暴力法**：每次查询区间和 O(n)，m 次查询 O(mn)
- **前缀和**：预处理 O(n)，每次查询 O(1)，m 次查询 O(n + m)
- **总复杂度**：O(n + m) vs O(mn)

---

## 二、前缀和适合的题目类型

### ✅ 1. **区间和查询（Range Sum Query）**
**特征**：多次查询数组某个区间 [i, j] 的元素和

**典型题目**：
- **303. Range Sum Query - Immutable**：多次查询区间和
- **304. Range Sum Query 2D - Immutable**：二维矩阵区间和查询

**示例**：
```
数组: [1, 2, 3, 4, 5]
查询1: sum([1, 3]) = 2 + 3 + 4 = 9
查询2: sum([0, 2]) = 1 + 2 + 3 = 6
```

### ✅ 2. **子数组和问题（Subarray Sum）**
**特征**：寻找满足条件的子数组（和等于某个值、和为0等）

**典型题目**：
- **560. Subarray Sum Equals K**：子数组和等于 K
- **525. Contiguous Array**：最长连续子数组（0和1数量相等）
- **974. Subarray Sums Divisible by K**：子数组和能被 K 整除

**关键技巧**：
- 子数组 `nums[i...j]` 的和 = `preSum[j+1] - preSum[i]`
- 如果 `preSum[j+1] - preSum[i] = k`，则 `preSum[j+1] = preSum[i] + k`
- 用哈希表记录前缀和出现的次数/位置

### ✅ 3. **左右分割问题（Left/Right Split）**
**特征**：需要比较数组左边和右边的和/积

**典型题目**：
- **724. Find Pivot Index**：左边和 = 右边和
- **238. Product Except Self**：左边乘积 × 右边乘积

**示例**：
```
Pivot Index: 找到索引 i，使得 sum(nums[0...i-1]) = sum(nums[i+1...n-1])
Product Except Self: answer[i] = product(nums[0...i-1]) × product(nums[i+1...n-1])
```

### ✅ 4. **前缀和 + 哈希表（Prefix Sum + Hash）**
**特征**：需要快速查找某个前缀和是否出现过

**典型题目**：
- **525. Contiguous Array**：用哈希表记录前缀和首次出现的位置
- **560. Subarray Sum Equals K**：用哈希表记录前缀和出现的次数
- **974. Subarray Sums Divisible by K**：用哈希表记录前缀和模 K 的余数

**关键思路**：
- 如果 `preSum[j] - preSum[i] = target`，则 `preSum[j] = preSum[i] + target`
- 遍历时，检查 `preSum[i] + target` 是否在哈希表中

### ✅ 5. **二维前缀和（2D Prefix Sum）**
**特征**：矩阵的子矩阵和查询

**典型题目**：
- **304. Range Sum Query 2D - Immutable**：二维矩阵区间和查询

**关键公式**：
```
preSum[i][j] = sum(matrix[0...i-1][0...j-1])
sumRegion(x1, y1, x2, y2) = preSum[x2+1][y2+1] - preSum[x1][y2+1] 
                           - preSum[x2+1][y1] + preSum[x1][y1]
```

### ✅ 6. **前缀和变形（Prefix Sum Variants）**
**特征**：前缀和的思想，但计算的是其他操作（乘积、异或等）

**典型题目**：
- **238. Product Except Self**：前缀乘积 × 后缀乘积
- **1310. XOR Queries of a Subarray**：前缀异或

---

## 三、如何快速判断使用前缀和？

### 🔍 判断标准（Checklist）

#### 1. **关键词识别**
看到以下关键词，考虑前缀和：
- ✅ "区间和" / "range sum"
- ✅ "子数组和" / "subarray sum"
- ✅ "多次查询" / "multiple queries"
- ✅ "快速查询" / "fast query"
- ✅ "左边和" / "右边和" / "left sum" / "right sum"
- ✅ "分割点" / "pivot" / "split"

#### 2. **问题模式识别**
- ✅ **模式1**：多次查询区间 [i, j] 的和
- ✅ **模式2**：寻找子数组，使得子数组和等于某个值
- ✅ **模式3**：比较数组左边和右边的和
- ✅ **模式4**：统计满足条件的子数组数量
- ✅ **模式5**：找到最长的满足条件的子数组

#### 3. **时间复杂度提示**
- ✅ 如果暴力法需要 O(mn)，而 m 和 n 都很大
- ✅ 如果有多次查询操作（m 很大）
- ✅ 如果每次查询都需要计算区间和

#### 4. **数据结构特征**
- ✅ 一维或二维数组
- ✅ 数组元素不可变（或很少变化）
- ✅ 查询操作远多于更新操作

---

## 四、不适合使用前缀和的情况

### ❌ 1. **数组频繁更新**
如果数组元素经常变化，前缀和需要重新计算，效率低
- **替代方案**：线段树、树状数组（支持区间更新和查询）

### ❌ 2. **只需要单次查询**
如果只查询一次，直接计算比预处理前缀和更快

### ❌ 3. **需要区间更新**
前缀和只支持查询，不支持区间更新
- **替代方案**：差分数组（区间更新）+ 前缀和（区间查询）

### ❌ 4. **需要区间最大值/最小值**
前缀和只适用于区间和，不适用于其他聚合操作
- **替代方案**：线段树、稀疏表（ST表）

---

## 五、经典题目分类

### 📚 基础题（区间查询）
1. **303. Range Sum Query - Immutable** - 基础前缀和
2. **304. Range Sum Query 2D - Immutable** - 二维前缀和

### 📚 子数组和问题
3. **560. Subarray Sum Equals K** - 子数组和等于 K（前缀和 + 哈希表）
4. **525. Contiguous Array** - 最长连续子数组（0和1数量相等）
5. **974. Subarray Sums Divisible by K** - 子数组和能被 K 整除

### 📚 左右分割问题
6. **724. Find Pivot Index** - 找到左边和 = 右边和的索引
7. **238. Product Except Self** - 前缀乘积 × 后缀乘积

### 📚 进阶题
8. **1310. XOR Queries of a Subarray** - 前缀异或
9. **930. Binary Subarrays With Sum** - 二进制子数组和
10. **1248. Count Number of Nice Subarrays** - 统计优美子数组

---

## 六、模板代码

### 一维前缀和
```python
class PrefixSum:
    def __init__(self, nums: List[int]):
        # preSum[i] = sum(nums[0...i-1])
        self.prefix = [0] * (len(nums) + 1)
        for i in range(1, len(self.prefix)):
            self.prefix[i] = self.prefix[i - 1] + nums[i - 1]
    
    def query(self, i: int, j: int) -> int:
        """查询区间 [i, j] 的和（包含两端）"""
        return self.prefix[j + 1] - self.prefix[i]
```

### 二维前缀和
```python
class NumMatrix:
    def __init__(self, matrix: List[List[int]]):
        m, n = len(matrix), len(matrix[0])
        # preSum[i][j] = sum(matrix[0...i-1][0...j-1])
        self.preSum = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                self.preSum[i][j] = (self.preSum[i-1][j] + self.preSum[i][j-1] 
                                    - self.preSum[i-1][j-1] + matrix[i-1][j-1])
    
    def sumRegion(self, x1: int, y1: int, x2: int, y2: int) -> int:
        """查询子矩阵 [x1, y1, x2, y2] 的和"""
        return (self.preSum[x2+1][y2+1] - self.preSum[x1][y2+1] 
                - self.preSum[x2+1][y1] + self.preSum[x1][y1])
```

### 前缀和 + 哈希表（子数组和问题）
```python
def subarraySum(nums: List[int], k: int) -> int:
    # preSum -> count
    prefix_count = {0: 1}  # 初始前缀和为 0 出现 1 次
    preSum = 0
    count = 0
    
    for num in nums:
        preSum += num
        # 如果 preSum - k 在哈希表中，说明存在子数组和为 k
        if preSum - k in prefix_count:
            count += prefix_count[preSum - k]
        prefix_count[preSum] = prefix_count.get(preSum, 0) + 1
    
    return count
```

---

## 七、快速判断流程图

```
问题分析
    │
    ├─ 是否涉及区间和查询？
    │   ├─ 否 → 继续
    │   └─ 是 → ✅ 考虑前缀和
    │
    ├─ 是否涉及子数组和问题？
    │   ├─ 否 → 继续
    │   └─ 是 → ✅ 考虑前缀和 + 哈希表
    │
    ├─ 是否需要比较左右两边的和？
    │   ├─ 否 → 继续
    │   └─ 是 → ✅ 考虑前缀和
    │
    ├─ 数组是否频繁更新？
    │   ├─ 是 → ❌ 考虑线段树/树状数组
    │   └─ 否 → 继续
    │
    └─ 是否需要区间更新？
        ├─ 是 → ❌ 考虑差分数组 + 前缀和
        └─ 否 → ✅ 使用前缀和！
```

---

## 八、前缀和 vs 差分数组

### 对比表

| 特性 | 前缀和 | 差分数组 |
|------|--------|----------|
| **主要操作** | 区间查询 | 区间更新 |
| **时间复杂度** | 查询 O(1) | 更新 O(1) |
| **适用场景** | 多次查询 | 多次更新 |
| **数组变化** | 数组不变或很少变化 | 数组频繁变化 |
| **典型题目** | Range Sum Query | Range Addition |

### 组合使用
- **差分数组**：处理区间更新
- **前缀和**：从差分数组恢复原数组，或查询区间和
- **组合**：支持区间更新 + 区间查询

---

## 九、常见陷阱和注意事项

### ⚠️ 1. **索引偏移问题**
- 前缀和数组通常长度为 `n + 1`
- `preSum[i]` 表示 `sum(nums[0...i-1])`
- 查询 `sum(nums[i...j])` 使用 `preSum[j+1] - preSum[i]`

### ⚠️ 2. **边界处理**
- 初始化时 `preSum[0] = 0`（空数组的前缀和）
- 对于子数组和问题，哈希表初始化为 `{0: 1}`

### ⚠️ 3. **负数处理**
- 如果数组有负数，前缀和可能为负
- 哈希表仍然可以正常工作

### ⚠️ 4. **溢出问题**
- 前缀和可能很大，注意整数溢出
- Python 自动处理大整数，但其他语言需要注意

---

## 十、总结

### 核心判断标准：
1. ✅ **区间查询**：多次查询区间 [i, j] 的和
2. ✅ **子数组和**：寻找满足条件的子数组
3. ✅ **左右分割**：比较数组左边和右边的和
4. ✅ **数组不变**：数组元素不频繁变化

### 时间复杂度优势：
- **暴力法**：O(mn)
- **前缀和**：O(n + m)
- **优势**：当 m 和 n 都很大时，性能提升显著

### 记忆技巧：
- 看到"区间和" + "多次查询" → 前缀和
- 看到"子数组和" + "等于某个值" → 前缀和 + 哈希表
- 看到"左边和" + "右边和" → 前缀和
- 看到"多次更新" → 差分数组（不是前缀和）

### 关键公式：
- **区间和**：`sum(nums[i...j]) = preSum[j+1] - preSum[i]`
- **子数组和等于 k**：`preSum[j] - preSum[i] = k` → `preSum[j] = preSum[i] + k`
- **二维区间和**：`sum = preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]`


































