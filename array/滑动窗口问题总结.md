# 滑动窗口问题总结

## 一、滑动窗口的本质

**核心思想**：快慢双指针前后跟随，向后移动，维护一个动态窗口

**适用场景**：子数组/子串问题，找符合条件的最长/最短连续子数组

**关键优势**：利用"增量更新"特性，避免重复计算，时间复杂度通常为 O(n)

---

## 二、解题思路的三大核心问题

解决滑动窗口问题时，需要明确回答以下三个问题：

### 1. 何时右移 right 扩大窗口？
- 当窗口不满足条件时
- 当需要寻找更多元素时

### 2. 何时右移 left 缩小窗口？
- 当窗口满足条件时（找最短窗口）
- 当窗口不满足条件且无法继续扩大时（找最长窗口）

### 3. 何时更新结果？
- **找最短窗口**：在窗口满足条件时更新
- **找最长窗口**：在窗口不满足条件之前更新

---

## 三、滑动窗口模板

### 模板1：找最短窗口（如 Minimum Window Substring）

```python
def sliding_window_template_shortest(s, target):
    left, right = 0, 0
    window = {}  # 维护窗口状态
    valid = 0    # 快速判断窗口是否有效
    res = float('inf')
    
    while right < len(s):
        # 1. 扩大窗口
        c = s[right]
        right += 1
        # 更新窗口状态（增量更新）
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] == need[c]:
                valid += 1
        
        # 2. 判断是否需要收缩窗口
        while valid == len(need):  # 窗口满足条件
            # 3. 更新结果（在满足条件时更新）
            if right - left < res:
                res = right - left
                # 记录结果...
            
            # 缩小窗口
            d = s[left]
            left += 1
            # 更新窗口状态（增量更新）
            if d in need:
                if window[d] == need[d]:
                    valid -= 1
                window[d] -= 1
    
    return res
```

### 模板2：找最长窗口（如 Longest Substring Without Repeating Characters）

```python
def sliding_window_template_longest(s):
    left, right = 0, 0
    window = {}  # 维护窗口状态
    res = 0
    
    while right < len(s):
        # 1. 扩大窗口
        c = s[right]
        right += 1
        window[c] = window.get(c, 0) + 1
        
        # 2. 判断是否需要收缩窗口
        while window[c] > 1:  # 窗口不满足条件
            # 缩小窗口
            d = s[left]
            left += 1
            window[d] -= 1
        
        # 3. 更新结果（在不满足条件之前更新）
        res = max(res, right - left)
    
    return res
```

### 模板3：固定窗口大小（如 Permutation in String）

```python
def sliding_window_template_fixed(s, target_len):
    window = Counter(s[:target_len])  # 初始窗口
    target = Counter(target_str)
    
    if window == target:
        return True
    
    # 滑动固定大小的窗口
    for i in range(target_len, len(s)):
        # 移除左边字符
        window[s[i - target_len]] -= 1
        if window[s[i - target_len]] == 0:
            del window[s[i - target_len]]
        
        # 添加右边字符
        window[s[i]] += 1
        
        # 检查是否匹配
        if window == target:
            return True
    
    return False
```

---

## 四、经典问题分类

### 1. 最小窗口问题

#### 76. Minimum Window Substring
- **问题**：找到包含 t 中所有字符的最短子串
- **关键点**：
  - 使用 `window` 字典维护窗口字符计数
  - 使用 `valid` 计数器快速判断窗口是否有效
  - **优化**：增量更新，避免每次重新计算 Counter
- **时间复杂度**：O(n)
- **空间复杂度**：O(k)，k = len(t)

#### 1658. Minimum Operations to Reduce X to Zero
- **问题**：通过移除两端元素使 x 变为 0，求最少操作数
- **思路**：反窗口 - 找中间窗口使得 `window_sum == sum(nums) - x`
- **关键点**：
  - 边界情况：`target < 0` 返回 -1，`target == 0` 返回 `len(nums)`
  - 使用 `while left <= right` 避免索引越界
- **时间复杂度**：O(n)

### 2. 最长窗口问题

#### 3. Longest Substring Without Repeating Characters
- **问题**：找到最长无重复字符的子串
- **关键点**：
  - 使用哈希表记录字符出现次数
  - 当有重复时收缩窗口，直到无重复
  - 在窗口无重复时更新结果
- **时间复杂度**：O(n)

### 3. 固定窗口问题

#### 567. Permutation in String
- **问题**：判断 s2 是否包含 s1 的排列
- **关键点**：
  - 固定窗口大小 = len(s1)
  - 滑动窗口，每次只更新两端字符
  - 使用 Counter 比较窗口和目标
- **时间复杂度**：O(n)

#### 438. Find All Anagrams in String
- **问题**：找到所有 s 中 p 的变位词的起始索引
- **关键点**：类似 567，但需要记录所有匹配位置
- **时间复杂度**：O(n)

---

## 五、优化技巧

### 1. 增量更新 vs 重新计算

**❌ 低效方法**（O(n²)）：
```python
# 每次循环都重新计算整个窗口
window = s[left:right+1]  # O(窗口大小)
if validStr(window, t):  # O(窗口大小 + len(t))
    # ...
```

**✅ 高效方法**（O(n)）：
```python
# 增量更新窗口状态
window[c] = window.get(c, 0) + 1  # O(1)
if window[c] == need[c]:          # O(1)
    valid += 1
```

### 2. 使用 valid 计数器快速判断

**❌ 低效方法**：
```python
# 每次都要完整比较
if all(window[ch] >= need[ch] for ch in need):  # O(k)
    # ...
```

**✅ 高效方法**：
```python
# 直接判断计数器
if valid == len(need):  # O(1)
    # ...
```

### 3. 避免索引越界

**❌ 错误方法**：
```python
while right < len(nums):
    if window_sum > target:
        window_sum -= nums[left]  # 可能越界
        left += 1
```

**✅ 正确方法**：
```python
for right in range(len(nums)):
    window_sum += nums[right]
    while left <= right and window_sum > target:  # 确保 left <= right
        window_sum -= nums[left]
        left += 1
```

---

## 六、常见陷阱

### 1. 边界情况
- 空数组/空字符串
- 目标值无法达到（如 target < 0）
- 窗口大小为 0 或等于数组长度

### 2. 索引越界
- `left` 超过 `right`
- 访问 `nums[left]` 或 `nums[right]` 时越界

### 3. 窗口状态更新顺序
- 先更新窗口状态，再移动指针
- 先判断条件，再更新结果

### 4. 重复计算
- 避免每次循环都重新计算整个窗口
- 利用增量更新特性

---

## 七、问题识别技巧

### 适合用滑动窗口的特征：
1. ✅ 连续子数组/子串问题
2. ✅ 需要维护窗口状态（如字符计数、和、积等）
3. ✅ 找最长/最短满足条件的子数组
4. ✅ 数组/字符串已排序或可以排序

### 不适合用滑动窗口的特征：
1. ❌ 需要回溯的问题
2. ❌ 不连续的子序列问题
3. ❌ 需要动态规划的问题
4. ❌ 需要随机访问的问题

---

## 八、解题步骤

1. **识别问题类型**：最短窗口 / 最长窗口 / 固定窗口
2. **确定窗口状态**：需要维护什么（字符计数、和、积等）
3. **设计增量更新**：如何高效更新窗口状态
4. **确定收缩条件**：何时缩小窗口
5. **确定更新时机**：何时更新结果
6. **处理边界情况**：空数组、无法达到等

---

## 九、200字核心总结

滑动窗口是解决连续子数组/子串问题的经典技巧，本质是快慢双指针维护动态窗口。解题需明确三点：何时扩大窗口（不满足条件时）、何时缩小窗口（满足条件时找最短，不满足时找最长）、何时更新结果（满足时更新最短，不满足前更新最长）。关键优化是增量更新：用字典维护窗口状态，用计数器快速判断，避免每次重新计算整个窗口，将复杂度从O(n²)降至O(n)。常见模式包括最小窗口（如Minimum Window Substring）、最长窗口（如Longest Substring Without Repeating Characters）和固定窗口（如Permutation in String）。注意边界情况和索引越界，先更新状态再移动指针，利用滑动窗口的增量特性实现高效求解。




