# 差分数组（Difference Array）应用总结

## 一、差分数组的核心特点

### 1. 基本原理
- **差分数组**：记录相邻元素的差值
- **原数组**：通过前缀和从差分数组恢复
- **区间更新**：O(1) 时间复杂度完成区间增减操作

### 2. 时间复杂度优势
- **暴力法**：区间更新 O(n)，m 次操作 O(mn)
- **差分数组**：区间更新 O(1)，m 次操作 O(m)，最后恢复 O(n)
- **总复杂度**：O(m + n) vs O(mn)

---

## 二、差分数组适合的题目类型

### ✅ 1. **区间增减操作**
**特征**：对数组的某个区间 [i, j] 统一加上或减去某个值

**典型题目**：
- **370. Range Addition**：多次区间加法操作
- **1109. Corporate Flight Bookings**：多个航班区间预订座位
- **1094. Car Pooling**：多个行程的上下车操作

**示例**：
```
给定数组 [0,0,0,0,0]
操作1: [0,2] 区间 +10
操作2: [2,4] 区间 +5
操作3: [1,3] 区间 -3
求最终数组
```

### ✅ 2. **多次操作后查询最终结果**
**特征**：
- 有多次区间更新操作
- 不需要实时查询中间状态
- 只需要最终结果

**典型题目**：
- **370. Range Addition**：所有操作完成后返回最终数组
- **1109. Corporate Flight Bookings**：所有预订完成后，每个航班的座位数

### ✅ 3. **区间覆盖/计数问题**
**特征**：统计某个位置被多少个区间覆盖

**典型题目**：
- **1094. Car Pooling**：每个位置有多少乘客（被多少个行程覆盖）
- **1109. Corporate Flight Bookings**：每个航班被多少个预订覆盖

### ✅ 4. **一维数组的区间操作**
**特征**：问题可以转化为一维数组的区间更新

**典型题目**：
- 时间线问题（如拼车、航班预订）
- 位置/距离问题（如车站、站点）

---

## 三、如何快速判断使用差分数组？

### 🔍 判断标准（Checklist）

#### 1. **关键词识别**
看到以下关键词，考虑差分数组：
- ✅ "区间更新" / "range update"
- ✅ "多次操作" / "multiple operations"
- ✅ "统一增减" / "add/subtract to range"
- ✅ "覆盖" / "overlap"
- ✅ "最终结果" / "final result"

#### 2. **问题模式识别**
- ✅ **模式1**：给定多个区间 [i, j] 和值 val，对区间内所有元素 +val
- ✅ **模式2**：多次区间操作后，查询每个位置的最终值
- ✅ **模式3**：统计每个位置被多少个区间覆盖

#### 3. **时间复杂度提示**
- ✅ 如果暴力法需要 O(mn)，而 m 和 n 都很大
- ✅ 如果只需要最终结果，不需要中间状态查询
- ✅ 如果区间更新操作很多（m 很大）

#### 4. **数据结构特征**
- ✅ 一维数组
- ✅ 区间操作是主要操作
- ✅ 查询操作较少或只在最后查询

---

## 四、不适合使用差分数组的情况

### ❌ 1. **需要实时查询中间状态**
如果每次操作后都需要查询，差分数组没有优势

### ❌ 2. **区间操作不是主要操作**
如果主要是单点更新、单点查询，用普通数组或线段树更合适

### ❌ 3. **二维或多维数组**
差分数组主要适用于一维，二维需要二维差分数组（更复杂）

### ❌ 4. **需要支持区间查询（如区间和、区间最大值）**
差分数组只适合区间更新，不适合区间查询（需要线段树或树状数组）

---

## 五、经典题目分类

### 📚 基础题
1. **370. Range Addition** - 最基础的区间更新
2. **1109. Corporate Flight Bookings** - 区间预订问题

### 📚 应用题
3. **1094. Car Pooling** - 拼车问题（注意 exclusive）
4. **798. Smallest Rotation with Highest Score** - 旋转数组问题

### 📚 进阶题
5. **732. My Calendar III** - 区间覆盖计数
6. **1854. Maximum Population Year** - 人口统计问题

---

## 六、模板代码

```python
class Difference:
    def __init__(self, nums: List[int]):
        self.diff = [0] * len(nums)
        self.diff[0] = nums[0]
        for i in range(1, len(nums)):
            self.diff[i] = nums[i] - nums[i - 1]
    
    def increment(self, i: int, j: int, val: int):
        """区间 [i, j] 增加 val"""
        self.diff[i] += val
        if j + 1 < len(self.diff):
            self.diff[j + 1] -= val
    
    def result(self) -> List[int]:
        """恢复原数组"""
        res = [0] * len(self.diff)
        res[0] = self.diff[0]
        for i in range(1, len(self.diff)):
            res[i] = res[i - 1] + self.diff[i]
        return res
```

---

## 七、快速判断流程图

```
问题分析
    │
    ├─ 是否涉及区间更新操作？
    │   ├─ 否 → 不考虑差分数组
    │   └─ 是 → 继续
    │
    ├─ 是否需要实时查询中间状态？
    │   ├─ 是 → 考虑线段树/树状数组
    │   └─ 否 → 继续
    │
    ├─ 是否是一维数组？
    │   ├─ 否 → 考虑其他方法
    │   └─ 是 → 继续
    │
    └─ 是否只需要最终结果？
        ├─ 否 → 考虑其他方法
        └─ 是 → ✅ 使用差分数组！
```

---

## 八、总结

### 核心判断标准：
1. ✅ **区间更新**：对区间 [i, j] 统一操作
2. ✅ **多次操作**：有多个区间更新操作
3. ✅ **最终查询**：只需要最终结果，不需要中间状态
4. ✅ **一维数组**：问题可以转化为一维数组

### 时间复杂度优势：
- **暴力法**：O(mn)
- **差分数组**：O(m + n)
- **优势**：当 m 和 n 都很大时，性能提升显著

### 记忆技巧：
- 看到"区间更新" + "多次操作" + "最终结果" → 差分数组
- 看到"覆盖"、"重叠"、"预订" → 考虑差分数组
- 看到时间线、位置、站点问题 → 考虑差分数组

